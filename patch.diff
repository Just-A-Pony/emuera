diff --git a/Emuera/Emuera.csproj b/Emuera/Emuera.csproj
index 4d2af103..aff32a60 100644
--- a/Emuera/Emuera.csproj
+++ b/Emuera/Emuera.csproj
@@ -32,6 +32,7 @@
         <SelfContained>false</SelfContained>
         <IncludeNativeLibrariesForSelfExtract>true</IncludeNativeLibrariesForSelfExtract>
         <TieredCompilation>false</TieredCompilation>
+        <IncludeSourceRevisionInInformationalVersion>false</IncludeSourceRevisionInInformationalVersion>
     </PropertyGroup>
 
     <PropertyGroup Condition=" '$(Configuration)' == 'Debug-NAudio' ">
@@ -44,27 +45,36 @@
         <Optimize>true</Optimize>
     </PropertyGroup>
 
-    <PropertyGroup Condition="$(Configuration.Contains('NAudio'))">
-        <InformationalVersion>$(InformationalVersion) NAudio</InformationalVersion>
-    </PropertyGroup>
 
-    <ItemGroup Condition="$(Configuration.Contains('NAudio'))">
-        <PackageReference Include="NAudio.Core" Version="2.2.1" />
-        <PackageReference Include="NAudio.Wasapi" Version="2.2.1" />
-        <PackageReference Include="NAudio.Vorbis" Version="1.5.0" />
-    </ItemGroup>
-    
-    <ItemGroup Condition="!($(Configuration.Contains('NAudio')))">
-        <COMReference Include="WMPLib">
-            <Guid>{6BF52A50-394A-11D3-B153-00C04F79FAA6}</Guid>
-            <VersionMajor>1</VersionMajor>
-            <VersionMinor>0</VersionMinor>
-            <Lcid>0</Lcid>
-            <WrapperTool>tlbimp</WrapperTool>
-            <Isolated>False</Isolated>
-            <EmbedInteropTypes>True</EmbedInteropTypes>
-        </COMReference>
-    </ItemGroup>
+    <Choose>
+        <When Condition="$(Configuration.Contains('NAudio'))">
+            <PropertyGroup>
+                <InformationalVersion>$(InformationalVersion) NAudio</InformationalVersion>
+            </PropertyGroup>
+
+            <ItemGroup Condition="$(Configuration.Contains('NAudio'))">
+                <Compile Remove="Runtime/Utils/Sound.WMP.cs" />
+                <PackageReference Include="NAudio.Core" Version="2.2.1" />
+                <PackageReference Include="NAudio.Wasapi" Version="2.2.1" />
+                <PackageReference Include="NAudio.Vorbis" Version="1.5.0" />
+            </ItemGroup>
+        </When>
+        <Otherwise>
+            <ItemGroup>
+                <Compile Remove="Runtime/Utils/Sound.NAudio.cs" />
+                <Compile Remove="Runtime/Utils/NAudio_LoopStream.cs" />
+                <COMReference Include="WMPLib">
+                    <Guid>{6BF52A50-394A-11D3-B153-00C04F79FAA6}</Guid>
+                    <VersionMajor>1</VersionMajor>
+                    <VersionMinor>0</VersionMinor>
+                    <Lcid>0</Lcid>
+                    <WrapperTool>tlbimp</WrapperTool>
+                    <Isolated>False</Isolated>
+                    <EmbedInteropTypes>True</EmbedInteropTypes>
+                </COMReference>
+            </ItemGroup>
+        </Otherwise>
+    </Choose>
     
     <ItemGroup>
       <Compile Remove="artifacts\**" />
@@ -87,31 +97,34 @@
             <LastGenOutput>Settings.Designer.cs</LastGenOutput>
         </None>
     </ItemGroup>
-    <PropertyGroup>
-      <IncludeSourceRevisionInInformationalVersion>false</IncludeSourceRevisionInInformationalVersion>
-    </PropertyGroup>
-
-    <ItemGroup Condition="'$(Platform)' == 'x64'">
-        <None Update="Libs\Webp\x86_64\libsharpyuv.dll">
-            <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-            <TargetPath>libsharpyuv.dll</TargetPath>
-        </None>
-        <None Include="Libs\Webp\x86_64\libwebp.dll">
-            <TargetPath>libwebp.dll</TargetPath>
-            <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-        </None>
-    </ItemGroup>
-
-    <ItemGroup Condition="'$(Platform)' == 'x86'">
-        <None Update="Libs\Webp\x86\libsharpyuv.dll">
-            <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-            <TargetPath>libsharpyuv.dll</TargetPath>
-        </None>
-        <None Update="Libs\Webp\x86\libwebp_x86.dll">
-            <TargetPath>libwebp_x86.dll</TargetPath>
-            <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
-        </None>
-    </ItemGroup>
+    
+    <Choose>
+        <When Condition="'$(Platform)' == 'x64'">
+            <ItemGroup>
+                <None Update="Libs\Webp\x86_64\libsharpyuv.dll">
+                    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+                    <TargetPath>libsharpyuv.dll</TargetPath>
+                </None>
+                <None Include="Libs\Webp\x86_64\libwebp.dll">
+                    <TargetPath>libwebp.dll</TargetPath>
+                    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+                </None>
+            </ItemGroup>
+        </When>
+        <When Condition="'$(Platform)' == 'x86'">
+            <ItemGroup>
+                <None Update="Libs\Webp\x86\libsharpyuv.dll">
+                    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+                    <TargetPath>libsharpyuv.dll</TargetPath>
+                </None>
+                <None Update="Libs\Webp\x86\libwebp_x86.dll">
+                    <TargetPath>libwebp_x86.dll</TargetPath>
+                    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+                </None>
+            </ItemGroup>
+        </When>
+    </Choose>
+    
     <ItemGroup>
       <PackageReference Include="Enums.NET" Version="4.0.1" />
      <PackageReference Include="Microsoft.Windows.CsWin32" Version="0.3.49-beta">
diff --git a/Emuera/Runtime/Utils/NAudio_LoopStream.cs b/Emuera/Runtime/Utils/NAudio_LoopStream.cs
new file mode 100644
index 00000000..d7162d55
--- /dev/null
+++ b/Emuera/Runtime/Utils/NAudio_LoopStream.cs
@@ -0,0 +1,109 @@
+﻿/* Copyright 2020 Mark Heath
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation
+ * files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,
+ * modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software
+ * is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR
+ * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*/
+
+using System;
+using NAudio.Wave;
+
+namespace NAudio.Extras
+{
+    /// <summary>
+    /// Loopable WaveStream
+    /// </summary>
+    public class LoopStream : WaveStream
+    {
+        readonly WaveStream sourceStream;
+
+        /// <summary>
+        /// Creates a new Loop stream
+        /// </summary>
+        public LoopStream(WaveStream source)
+        {
+            sourceStream = source;
+        }
+
+        /// <summary>
+        /// The WaveFormat of this stream
+        /// </summary>
+        public override WaveFormat WaveFormat
+        {
+            get { return sourceStream.WaveFormat; }
+        }
+
+        /// <summary>
+        /// Length in bytes of this stream (effectively infinite)
+        /// </summary>
+        public override long Length
+        {
+            get { return long.MaxValue / 32; }
+        }
+
+        /// <summary>
+        /// Position within this stream in bytes
+        /// </summary>
+        public override long Position
+        {
+            get
+            {
+                return sourceStream.Position;
+            }
+            set
+            {
+                sourceStream.Position = value;
+            }
+        }
+
+        /// <summary>
+        /// Always has data available
+        /// </summary>
+        public override bool HasData(int count)
+        {
+            // infinite loop
+            return true;
+        }
+
+        /// <summary>
+        /// Read data from this stream
+        /// </summary>
+        public override int Read(byte[] buffer, int offset, int count)
+        {
+            int read = 0;
+            while (read < count)
+            {
+                int required = count - read;
+                int readThisTime = sourceStream.Read(buffer, offset + read, required);
+                if (readThisTime < required)
+                {
+                    sourceStream.Position = 0;
+                }
+
+                if (sourceStream.Position >= sourceStream.Length)
+                {
+                    sourceStream.Position = 0;
+                }
+                read += readThisTime;
+            }
+            return read;
+        }
+
+        /// <summary>
+        /// Dispose this WaveStream (disposes the source)
+        /// </summary>
+        protected override void Dispose(bool disposing)
+        {
+            sourceStream.Dispose();
+            base.Dispose(disposing);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Emuera/Runtime/Utils/Sound.NAudio.cs b/Emuera/Runtime/Utils/Sound.NAudio.cs
new file mode 100644
index 00000000..6d870759
--- /dev/null
+++ b/Emuera/Runtime/Utils/Sound.NAudio.cs
@@ -0,0 +1,427 @@
+﻿using System;
+using System.Threading;
+using System.Diagnostics;
+using NAudio.Wave;
+using NAudio.Wave.SampleProviders;
+using NAudio.CoreAudioApi;
+using NAudio.Extras;
+using NAudio.Vorbis;
+using NAudio.CoreAudioApi.Interfaces;
+
+namespace MinorShift._Library
+{
+	internal class AudioDeviceTracker : IMMNotificationClient
+	{
+		private readonly SynchronizationContext syncContext;
+		private MMDeviceEnumerator enumerator;
+		public MMDevice Device { get; private set; }
+		public event EventHandler<MMDevice> DefaultDeviceChanged;
+
+		public AudioDeviceTracker()
+		{
+			if (SynchronizationContext.Current == null)
+				throw new Exception("SynchronizationContext.Current is null");
+
+			syncContext = SynchronizationContext.Current;
+			enumerator = new MMDeviceEnumerator();
+
+			if (enumerator.HasDefaultAudioEndpoint(DataFlow.Render, Role.Console))
+				Device = enumerator.GetDefaultAudioEndpoint(DataFlow.Render, Role.Console);
+			else
+				Device = null;
+
+			enumerator.RegisterEndpointNotificationCallback(this);
+		}
+
+		~AudioDeviceTracker()
+		{
+			enumerator.UnregisterEndpointNotificationCallback(this);
+		}
+
+		public void OnDefaultDeviceChanged(DataFlow flow, Role role, string defaultDeviceId)
+		{
+			if (flow != DataFlow.Render || role != Role.Console)
+				return;
+
+			syncContext.Post(DispatchDefaultDeviceChanged, defaultDeviceId);
+		}
+
+		private void DispatchDefaultDeviceChanged(object defaultDeviceId)
+		{
+			if (Device?.ID != (string)defaultDeviceId)
+			{
+				if (defaultDeviceId == null)
+					Device = null;
+				else
+					Device = enumerator.GetDevice((string)defaultDeviceId);
+
+				var handler = DefaultDeviceChanged;
+				if (handler != null)
+				{
+					handler(this, Device);
+				}
+			}
+		}
+
+		public void OnDeviceStateChanged(string deviceId, DeviceState newState) { }
+		public void OnDeviceAdded(string pwstrDeviceId) { }
+		public void OnDeviceRemoved(string deviceId) { }
+		public void OnPropertyValueChanged(string pwstrDeviceId, PropertyKey key) { }
+	}
+
+	internal class DummyOut : IWavePlayer
+	{
+		private readonly SynchronizationContext syncContext;
+		private volatile PlaybackState playbackState = PlaybackState.Stopped;
+		private Thread playThread;
+		private ISampleProvider sampleProvider;
+		private int latency;
+		public float Volume { get; set; }
+		public PlaybackState PlaybackState { get => playbackState; }
+		public WaveFormat OutputWaveFormat { get; }
+		public event EventHandler<StoppedEventArgs> PlaybackStopped;
+
+		public DummyOut(int latency)
+		{
+			syncContext = SynchronizationContext.Current;
+			this.latency = latency;
+		}
+
+		public void Play()
+		{
+			if (playbackState != PlaybackState.Playing)
+			{
+				if (playbackState == PlaybackState.Stopped)
+				{
+					playThread = new Thread(PlayThread);
+					playThread.IsBackground = true;
+					playbackState = PlaybackState.Playing;
+					playThread.Start();
+				}
+				else
+				{
+					playbackState = PlaybackState.Playing;
+				}
+			}
+		}
+
+		public void Stop()
+		{
+			if (playbackState != PlaybackState.Stopped)
+			{
+				playbackState = PlaybackState.Stopped;
+				playThread.Join();
+				playThread = null;
+			}
+		}
+		public void Pause()
+		{
+			if (playbackState == PlaybackState.Playing)
+				playbackState = PlaybackState.Paused;
+		}
+		public void Init(IWaveProvider waveProvider)
+		{
+			sampleProvider = waveProvider.ToSampleProvider();
+		}
+		public void Dispose()
+		{
+			Stop();
+		}
+
+		private void PlayThread()
+		{
+			Exception exception = null;
+			try
+			{
+				Stopwatch stopwatch = Stopwatch.StartNew();
+				TimeSpan prevTime = TimeSpan.Zero;
+				var format = sampleProvider.WaveFormat;
+				float[] buffer = new float[format.SampleRate * format.Channels];
+				int samplesRemaining = 0;
+
+				while (playbackState != PlaybackState.Stopped)
+				{
+					Thread.Sleep(latency);
+					if (playbackState == PlaybackState.Playing)
+					{
+						if (!stopwatch.IsRunning)
+						{
+							stopwatch.Start();
+							continue;
+						}
+
+						TimeSpan now = stopwatch.Elapsed;
+						TimeSpan delta = now - prevTime;
+						prevTime = now;
+
+						samplesRemaining += (int)(delta.TotalSeconds * format.SampleRate * format.Channels);
+						while (samplesRemaining > format.Channels)
+						{
+							int count = Math.Min(buffer.Length, samplesRemaining);
+							count -= count % format.Channels;
+							int samplesRead = sampleProvider.Read(buffer, 0, count);
+							samplesRemaining -= samplesRead;
+							if (samplesRead == 0)
+							{
+								playbackState = PlaybackState.Stopped;
+								break;
+							}
+						}
+					}
+					else if (playbackState == PlaybackState.Paused)
+					{
+						if (stopwatch.IsRunning)
+						{
+							stopwatch.Reset();
+							prevTime = TimeSpan.Zero;
+						}
+					}
+				}
+			}
+			catch (Exception e)
+			{
+				exception = e;
+			}
+			finally
+			{
+				var handler = PlaybackStopped;
+				if (handler != null)
+				{
+					if (syncContext == null)
+						handler(this, new StoppedEventArgs(exception));
+					else
+						syncContext.Post(state => handler(this, new StoppedEventArgs(exception)), null);
+				}
+			}
+		}
+	}
+
+	internal class RepeatStream : WaveStream
+	{
+		readonly WaveStream sourceStream;
+		readonly int total_count;
+		int remaining_count;
+
+		public RepeatStream(WaveStream source, int count)
+		{
+			sourceStream = source;
+			total_count = count;
+			remaining_count = count;
+		}
+
+		public override WaveFormat WaveFormat
+		{
+			get { return sourceStream.WaveFormat; }
+		}
+
+		public override long Length
+		{
+			get { return sourceStream.Length * total_count; }
+		}
+
+		public override long Position
+		{
+			get
+			{
+				return (total_count - remaining_count) * sourceStream.Length + sourceStream.Position;
+			}
+			set
+			{
+				remaining_count = (int)(value / sourceStream.Length);
+				sourceStream.Position = value % sourceStream.Length;
+			}
+		}
+
+		public override bool HasData(int count)
+		{
+			return sourceStream.Position < sourceStream.Length;
+		}
+
+		public override int Read(byte[] buffer, int offset, int count)
+		{
+			int total_read = 0;
+			while (total_read < count)
+			{
+				int remaining = count - total_read;
+				int read = sourceStream.Read(buffer, offset + total_read, remaining);
+				if (read < remaining || sourceStream.Position >= sourceStream.Length)
+				{
+					if (remaining_count > 1)
+					{
+						remaining_count--;
+						sourceStream.Position = 0;
+					}
+					else
+					{
+						return total_read + read;
+					}
+				}
+				total_read += read;
+			}
+			return total_read;
+		}
+
+		protected override void Dispose(bool disposing)
+		{
+			sourceStream.Dispose();
+			base.Dispose(disposing);
+		}
+	}
+
+	internal static class SoundMixer
+	{
+		private static bool initialized = false;
+		public static bool Initialized { get => initialized; }
+		public const int SampleRate = 44100;
+		private static AudioDeviceTracker deviceTracker;
+		private static IWavePlayer output;
+		private static MixingSampleProvider mixer;
+
+		public static void Initialize()
+		{
+			if (initialized)
+				return;
+
+			mixer = new MixingSampleProvider(WaveFormat.CreateIeeeFloatWaveFormat(SampleRate, 2));
+			mixer.ReadFully = true;
+			mixer.MixerInputEnded += SoundEnded;
+
+			deviceTracker = new AudioDeviceTracker();
+			InitializeOutput(deviceTracker.Device);
+			deviceTracker.DefaultDeviceChanged += ChangeOutput;
+
+			initialized = true;
+		}
+
+		private static void SoundEnded(object sender, SampleProviderEventArgs args)
+		{
+			((Sound)(args.SampleProvider)).Playing = false;
+		}
+
+		private static void InitializeOutput(MMDevice device)
+		{
+			if (SynchronizationContext.Current == null)
+				throw new Exception("SynchronizationContext.Current is null");
+
+			if (device != null)
+				output = new WasapiOut(device, AudioClientShareMode.Shared, true, 50);
+			else
+				output = new DummyOut(200);
+
+			output.Init(mixer);
+			output.Play();
+		}
+
+		private static void ChangeOutput(object sender, MMDevice device)
+		{
+			if (output != null)
+				output.Dispose();
+
+			InitializeOutput(device);
+		}
+
+		public static void PlaySound(Sound sound)
+		{
+			sound.Playing = true;
+			mixer.AddMixerInput(sound);
+		}
+
+		public static void StopSound(Sound sound)
+		{
+			sound.Playing = false;
+			mixer.RemoveMixerInput(sound);
+		}
+	}
+
+	internal class Sound : ISampleProvider
+	{
+		private float volume = 1.0f;
+
+		private WaveStream stream;
+		private VolumeSampleProvider volumeProvider;
+		public volatile bool Playing = false;
+		public WaveFormat WaveFormat { get => volumeProvider.WaveFormat; }
+
+		public int Read(float[] buffer, int offset, int count)
+		{
+			return volumeProvider.Read(buffer, offset, count);
+		}
+
+		public void play(string filename, int repeat = 1)
+		{
+			if (!SoundMixer.Initialized)
+				SoundMixer.Initialize();
+
+			stop();
+
+			if (filename.EndsWith(".wav", StringComparison.OrdinalIgnoreCase))
+			{
+				stream = new WaveFileReader(filename);
+			}
+			else if (filename.EndsWith(".ogg", StringComparison.OrdinalIgnoreCase))
+			{
+				stream = new VorbisWaveReader(filename);
+			}
+			else
+			{
+				// NOTE: MediaFoundationReader currently seems to only support 16 bit audio files on wine
+				var settings = new MediaFoundationReader.MediaFoundationReaderSettings();
+				settings.RequestFloatOutput = true;
+				stream = new MediaFoundationReader(filename, settings);
+			}
+
+			WaveStream _stream = stream;
+			// LoopStream / RepeatStream might cause issues because they seek (see comment in stop method below)
+			if (repeat == -1)
+				_stream = new LoopStream(_stream);
+			else if (repeat > 1)
+				_stream = new RepeatStream(_stream, repeat);
+
+			// MediaFoundationResampler is faster and possibly higher quality than WdlResamplingSampleProvider but currently doesn't seem to work on wine
+			// var resampler = new MediaFoundationResampler(_stream, WaveFormat.CreateIeeeFloatWaveFormat(sampleRate, 2));
+			// volumeProvider = new VolumeSampleProvider(resampler.ToSampleProvider());
+
+			ISampleProvider sampleProvider = _stream.ToSampleProvider();
+			if (sampleProvider.WaveFormat.SampleRate != SoundMixer.SampleRate)
+				sampleProvider = new WdlResamplingSampleProvider(sampleProvider, SoundMixer.SampleRate);
+			if (sampleProvider.WaveFormat.Channels == 1)
+				sampleProvider = sampleProvider.ToStereo();
+			volumeProvider = new VolumeSampleProvider(sampleProvider);
+
+			volumeProvider.Volume = volume;
+
+			SoundMixer.PlaySound(this);
+		}
+
+		public void stop()
+		{
+			if (SoundMixer.Initialized)
+				SoundMixer.StopSound(this);
+
+			// don't try to reuse the stream because repositioning a MediaFoundationReader to the beginning sometimes causes WasapiOut to hang when the stream is next read (observed with a 48khz 24 bit FLAC file)
+			if (stream != null)
+			{
+				stream.Dispose();
+				stream = null;
+			}
+		}
+
+		public void close()
+		{
+			stop();
+			volumeProvider = null;
+		}
+
+		public bool isPlaying()
+		{
+			return Playing;
+		}
+
+		public void setVolume(int volume)
+		{
+			this.volume = Math.Clamp(volume, 0, 100) / 100.0f;
+			if (volumeProvider != null)
+				volumeProvider.Volume = this.volume;
+		}
+	}
+}

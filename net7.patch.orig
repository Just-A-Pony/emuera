diff --git a/.gitignore b/.gitignore
index 8e2464a..206d35b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,3 +1,4 @@
 .vs/*
 Emuera/bin/*
 Emuera/obj/*
+Emuera/Properties/PublishProfiles/FolderProfile.pubxml.user
\ No newline at end of file
diff --git a/Emuera.sln b/Emuera.sln
index 8c8fd4e..4ce13a7 100644
--- a/Emuera.sln
+++ b/Emuera.sln
@@ -1,7 +1,9 @@
 ﻿
-Microsoft Visual Studio Solution File, Format Version 11.00
-# Visual C# Express 2010
-Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Emuera", "Emuera\Emuera.csproj", "{F3B2ED56-A5BF-45DA-A270-3ED0F775320B}"
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio Version 17
+VisualStudioVersion = 17.6.33723.286
+MinimumVisualStudioVersion = 10.0.40219.1
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Emuera", "Emuera\Emuera.csproj", "{6DF78E83-F428-4CD8-887A-F1B9CA0F0670}"
 EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
@@ -9,12 +11,15 @@ Global
 		Release|Any CPU = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
-		{F3B2ED56-A5BF-45DA-A270-3ED0F775320B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{F3B2ED56-A5BF-45DA-A270-3ED0F775320B}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{F3B2ED56-A5BF-45DA-A270-3ED0F775320B}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{F3B2ED56-A5BF-45DA-A270-3ED0F775320B}.Release|Any CPU.Build.0 = Release|Any CPU
+		{6DF78E83-F428-4CD8-887A-F1B9CA0F0670}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{6DF78E83-F428-4CD8-887A-F1B9CA0F0670}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{6DF78E83-F428-4CD8-887A-F1B9CA0F0670}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{6DF78E83-F428-4CD8-887A-F1B9CA0F0670}.Release|Any CPU.Build.0 = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
 	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+		SolutionGuid = {CD7FF2B4-7A65-4100-9B51-FF87DDFA8468}
+	EndGlobalSection
 EndGlobal
diff --git a/Emuera/.editorconfig b/Emuera/.editorconfig
index e93a198..0208f79 100644
--- a/Emuera/.editorconfig
+++ b/Emuera/.editorconfig
@@ -3,6 +3,7 @@
 indent_size = 4
 indent_style = tab
 charset = utf-8-bom
+dotnet_diagnostic.CA1416.severity = none
 
 [_Library/ImageProcessor/*.cs]
 indent_size = 4
diff --git a/Emuera/Emuera.csproj b/Emuera/Emuera.csproj
index 4489082..04a6a2c 100644
--- a/Emuera/Emuera.csproj
+++ b/Emuera/Emuera.csproj
@@ -1,100 +1,42 @@
 ﻿<Project Sdk="Microsoft.NET.Sdk">
+
   <PropertyGroup>
-    <TargetFramework>net7.0-windows</TargetFramework>
     <OutputType>WinExe</OutputType>
-    <RootNamespace>MinorShift.Emuera</RootNamespace>
-    <IsWebBootstrapper>false</IsWebBootstrapper>
-    <PublishUrl>publish\</PublishUrl>
-    <Install>true</Install>
-    <InstallFrom>Disk</InstallFrom>
-    <UpdateEnabled>false</UpdateEnabled>
-    <UpdateMode>Foreground</UpdateMode>
-    <UpdateInterval>7</UpdateInterval>
-    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
-    <UpdatePeriodically>false</UpdatePeriodically>
-    <UpdateRequired>false</UpdateRequired>
-    <MapFileExtensions>true</MapFileExtensions>
-    <ApplicationRevision>0</ApplicationRevision>
-    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
-    <UseApplicationTrust>false</UseApplicationTrust>
-    <BootstrapperEnabled>true</BootstrapperEnabled>
-    <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
-    <UseWindowsForms>true</UseWindowsForms>
-    <UseWPF>true</UseWPF>
-    <ImportWindowsDesktopTargets>true</ImportWindowsDesktopTargets>
-  	<Deterministic>false</Deterministic>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>none</DebugType>
-    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
+    <TargetFramework>net7.0-windows</TargetFramework>
+	  <RootNamespace>MinorShift.Emuera</RootNamespace>
+	  <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+	  <ApplicationRevision>0</ApplicationRevision>
+	  <UseWindowsForms>true</UseWindowsForms>
+	  <UseWPF>true</UseWPF>
+	  <Nullable>enable</Nullable>
+	  <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
+	  <GenerateAssemblyInfo>false</GenerateAssemblyInfo>
+	  <Deterministic>false</Deterministic>
   </PropertyGroup>
-  <ItemGroup>
-    <Compile Update="Forms\ColorBox.cs" />
-    <Compile Update="Forms\EraPictureBox.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <COMReference Include="WMPLib">
-      <Guid>{6BF52A50-394A-11D3-B153-00C04F79FAA6}</Guid>
-      <VersionMajor>1</VersionMajor>
-      <VersionMinor>0</VersionMinor>
-      <Lcid>0</Lcid>
-      <WrapperTool>tlbimp</WrapperTool>
-      <Isolated>False</Isolated>
-      <EmbedInteropTypes>True</EmbedInteropTypes>
-    </COMReference>
-  </ItemGroup>
-  <ItemGroup>
-    <WCFMetadata Include="Connected Services\" />
-  </ItemGroup>
-  <ItemGroup>
-    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
-      <Visible>False</Visible>
-      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
-      <Install>false</Install>
-    </BootstrapperPackage>
-    <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
-      <Visible>False</Visible>
-      <ProductName>.NET Framework 2.0 %28x86%29</ProductName>
-      <Install>true</Install>
-    </BootstrapperPackage>
-    <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
-      <Visible>False</Visible>
-      <ProductName>.NET Framework 3.0 %28x86%29</ProductName>
-      <Install>false</Install>
-    </BootstrapperPackage>
-    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
-      <Visible>False</Visible>
-      <ProductName>.NET Framework 3.5</ProductName>
-      <Install>false</Install>
-    </BootstrapperPackage>
-    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
-      <Visible>False</Visible>
-      <ProductName>.NET Framework 3.5 SP1</ProductName>
-      <Install>false</Install>
-    </BootstrapperPackage>
-  </ItemGroup>
-  <ItemGroup>
-    <Content Include="_Library\ImageProcessor\Imaging\Filters\ObjectDetection\Resources\haarcascade_frontalface_alt.xml" />
-    <Content Include="_Library\ImageProcessor\Imaging\Filters\ObjectDetection\Resources\haarcascade_frontalface_default.xml" />
-    <Content Include="_Library\ImageProcessor\Imaging\Filters\ObjectDetection\Resources\haarcascade_frontalface_legacy.xml" />
-    <Content Include="_Library\ImageProcessor\Resources\Unmanaged\README.txt" />
-    <Content Include="_Library\ImageProcessor\Resources\Unmanaged\x64\libwebp.dll" />
-    <Content Include="_Library\ImageProcessor\Resources\Unmanaged\x86\libwebp.dll" />
-  </ItemGroup>
-  <ItemGroup>
-    <PackageReference Include="Costura.Fody" Version="5.7.0">
-      <PrivateAssets>all</PrivateAssets>
-      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
-    </PackageReference>
-    <PackageReference Include="Microsoft.CSharp" Version="4.7.0" />
-    <PackageReference Include="Microsoft.VisualBasic" Version="10.3.0" />
-    <PackageReference Include="System.Data.DataSetExtensions" Version="4.5.0" />
-    <PackageReference Include="Microsoft.DotNet.UpgradeAssistant.Extensions.Default.Analyzers" Version="0.4.410601">
-      <PrivateAssets>all</PrivateAssets>
-    </PackageReference>
-    <PackageReference Include="Microsoft.Windows.Compatibility" Version="7.0.0" />
-  </ItemGroup>
+	<ItemGroup>
+		<COMReference Include="WMPLib">
+			<Guid>{6BF52A50-394A-11D3-B153-00C04F79FAA6}</Guid>
+			<VersionMajor>1</VersionMajor>
+			<VersionMinor>0</VersionMinor>
+			<Lcid>0</Lcid>
+			<WrapperTool>tlbimp</WrapperTool>
+			<Isolated>False</Isolated>
+			<EmbedInteropTypes>True</EmbedInteropTypes>
+		</COMReference>
+	</ItemGroup>
+
+	<ItemGroup>
+	  <Compile Update="Properties\Settings.Designer.cs">
+	    <DesignTimeSharedInput>True</DesignTimeSharedInput>
+	    <AutoGen>True</AutoGen>
+	    <DependentUpon>Settings.settings</DependentUpon>
+	  </Compile>
+	</ItemGroup>
+	<ItemGroup>
+	  <None Update="Properties\Settings.settings">
+	    <Generator>SettingsSingleFileGenerator</Generator>
+	    <LastGenOutput>Settings.Designer.cs</LastGenOutput>
+	  </None>
+	</ItemGroup>
+
 </Project>
\ No newline at end of file
diff --git a/Emuera/Emuera.csproj.user b/Emuera/Emuera.csproj.user
index d18a3d9..e8dd05c 100644
--- a/Emuera/Emuera.csproj.user
+++ b/Emuera/Emuera.csproj.user
@@ -1,29 +1,6 @@
 ﻿<?xml version="1.0" encoding="utf-8"?>
-<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <PropertyGroup>
-    <PublishUrlHistory>publish\</PublishUrlHistory>
-    <InstallUrlHistory>
-    </InstallUrlHistory>
-    <SupportUrlHistory>
-    </SupportUrlHistory>
-    <UpdateUrlHistory>
-    </UpdateUrlHistory>
-    <BootstrapperUrlHistory>
-    </BootstrapperUrlHistory>
-    <ErrorReportUrlHistory>
-    </ErrorReportUrlHistory>
-    <FallbackCulture>ja-JP</FallbackCulture>
-    <VerifyUploadedFiles>false</VerifyUploadedFiles>
-    <ProjectView>ShowAllFiles</ProjectView>
-    <_LastSelectedProfileId>C:\Users\catgi\Dropbox\git_EmueraEMEE\Emuera\Properties\PublishProfiles\FolderProfile.pubxml</_LastSelectedProfileId>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
-    <StartArguments>
-    </StartArguments>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
-    <StartArguments>
-    </StartArguments>
   </PropertyGroup>
   <ItemGroup>
     <Compile Update="Forms\ClipBoardDialog.cs">
diff --git a/Emuera/Forms/MainWindow.cs b/Emuera/Forms/MainWindow.cs
index 23ad034..bf18010 100644
--- a/Emuera/Forms/MainWindow.cs
+++ b/Emuera/Forms/MainWindow.cs
@@ -1,4 +1,5 @@
 ﻿using System;
+using System.Diagnostics;
 using System.Collections.Generic;
 using System.ComponentModel;
 using System.Drawing;
@@ -91,7 +92,8 @@ namespace MinorShift.Emuera
 			#endregion
 		}
 		private ToolStripMenuItem[] macroMenuItems = new ToolStripMenuItem[KeyMacro.MaxFkey];
-        private System.Diagnostics.FileVersionInfo emueraVer = System.Diagnostics.FileVersionInfo.GetVersionInfo(System.Reflection.Assembly.GetExecutingAssembly().Location);
+		//private System.Diagnostics.FileVersionInfo emueraVer = System.Diagnostics.FileVersionInfo.GetVersionInfo(System.Reflection.Assembly.GetExecutingAssembly().Location);
+		private System.Diagnostics.FileVersionInfo emueraVer = System.Diagnostics.FileVersionInfo.GetVersionInfo(Process.GetCurrentProcess().MainModule.FileName);
 		public PictureBox MainPicBox { get { return mainPicBox; } }
 		public VScrollBar ScrollBar { get { return vScrollBar; } }
 		public RichTextBox TextBox { get { return richTextBox1; } }
diff --git a/Emuera/GameProc/Process.cs b/Emuera/GameProc/Process.cs
index 1fa50cf..c8077c4 100644
--- a/Emuera/GameProc/Process.cs
+++ b/Emuera/GameProc/Process.cs
@@ -5,6 +5,7 @@ using System.IO;
 using System.Windows.Forms;
 using MinorShift.Emuera.GameData;
 using MinorShift.Emuera.Sub;
+using MinorShift._Library;
 using MinorShift.Emuera.GameView;
 using MinorShift.Emuera.GameData.Expression;
 using MinorShift.Emuera.GameData.Variable;
@@ -286,7 +287,7 @@ namespace MinorShift.Emuera.GameProc
 		
 		public void DoScript()
 		{
-			startTime = _Library.WinmmTimer.TickCount;
+			startTime = WinmmTimer.TickCount;
 			state.lineCount = 0;
 			bool systemProcRunning = true;
 			try
@@ -324,7 +325,7 @@ namespace MinorShift.Emuera.GameProc
 
 		public void UpdateCheckInfiniteLoopState()
 		{
-			startTime = _Library.WinmmTimer.TickCount;
+			startTime = WinmmTimer.TickCount;
 			state.lineCount = 0;
 		}
 
@@ -341,7 +342,7 @@ namespace MinorShift.Emuera.GameProc
 			//    console.ReadAnyKey();
 			//    return;
 			//}
-			uint time = _Library.WinmmTimer.TickCount - startTime;
+			uint time = WinmmTimer.TickCount - startTime;
 			if (time < Config.InfiniteLoopAlertTime)
 				return;
 			LogicalLine currentLine = state.CurrentLine;
@@ -361,7 +362,7 @@ namespace MinorShift.Emuera.GameProc
 			else
 			{
 				state.lineCount = 0;
-				startTime = _Library.WinmmTimer.TickCount;
+				startTime = WinmmTimer.TickCount;
 			}
 		}
 
diff --git a/Emuera/Properties/PublishProfiles/FolderProfile.pubxml b/Emuera/Properties/PublishProfiles/FolderProfile.pubxml
index fed7f0b..b4a183f 100644
--- a/Emuera/Properties/PublishProfiles/FolderProfile.pubxml
+++ b/Emuera/Properties/PublishProfiles/FolderProfile.pubxml
@@ -6,13 +6,13 @@ https://go.microsoft.com/fwlink/?LinkID=208121.
   <PropertyGroup>
     <Configuration>Release</Configuration>
     <Platform>Any CPU</Platform>
-    <PublishDir>bin\Release\net7.0-windows\publish\linux-x64\</PublishDir>
+    <PublishDir>bin\Release\publish\</PublishDir>
     <PublishProtocol>FileSystem</PublishProtocol>
     <_TargetId>Folder</_TargetId>
     <TargetFramework>net7.0-windows</TargetFramework>
     <SelfContained>false</SelfContained>
     <RuntimeIdentifier>win-x64</RuntimeIdentifier>
+    <PublishReadyToRun>false</PublishReadyToRun>
     <PublishSingleFile>true</PublishSingleFile>
-    <PublishReadyToRun>true</PublishReadyToRun>
   </PropertyGroup>
 </Project>
\ No newline at end of file
diff --git a/Emuera/Properties/PublishProfiles/FolderProfile.pubxml.user b/Emuera/Properties/PublishProfiles/FolderProfile.pubxml.user
deleted file mode 100644
index c057a2c..0000000
diff --git a/Emuera/_Library/EvilMask/Utils.cs b/Emuera/_Library/EvilMask/Utils.cs
index cc684b9..2d03677 100644
--- a/Emuera/_Library/EvilMask/Utils.cs
+++ b/Emuera/_Library/EvilMask/Utils.cs
@@ -9,6 +9,7 @@ using System.Diagnostics;
 using System.Drawing;
 using System.IO;
 using System.Text;
+using WebPWrapper;
 
 namespace EvilMask.Emuera
 {
@@ -239,22 +240,25 @@ namespace EvilMask.Emuera
 		static public Bitmap LoadImage(string filepath)
 		{
 			Bitmap bmp = null;
-			FileStream fs = null;
+			//FileStream fs = null;
 			if (!File.Exists(filepath)) return null;
-
 			try
 			{
-				fs = new FileStream(filepath, FileMode.Open);
-				var factory = new ImageProcessor.ImageFactory();
-				factory.Load(fs);
-				bmp = (Bitmap)factory.Image;
-			}
-			catch { }
-			finally
-			{
-				fs?.Close();
-				fs?.Dispose();
+				/*				fs = new FileStream(filepath, FileMode.Open);
+								var factory = new ImageProcessor.ImageFactory();
+								factory.Load(fs);
+								bmp = (Bitmap)factory.Image;*/
+				if (Path.GetExtension(filepath).ToLower() == ".webp")
+				{
+					using WebP webp = new();
+					bmp = webp.Load(filepath);
+				}
+				else
+				{
+					bmp = new Bitmap(filepath);
+				}
 			}
+			catch{ }
 			return bmp;
 
 		}
diff --git a/Emuera/_Library/ImageProcessor/BitDepth.cs b/Emuera/_Library/ImageProcessor/BitDepth.cs
deleted file mode 100644
index 9dda682..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Exceptions/ImageFormatException.cs b/Emuera/_Library/ImageProcessor/Common/Exceptions/ImageFormatException.cs
deleted file mode 100644
index 6254167..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Exceptions/ImageProcessingException.cs b/Emuera/_Library/ImageProcessor/Common/Exceptions/ImageProcessingException.cs
deleted file mode 100644
index 7bb9367..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Exceptions/Logging/DefaultLogger.cs b/Emuera/_Library/ImageProcessor/Common/Exceptions/Logging/DefaultLogger.cs
deleted file mode 100644
index 748e69f..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Exceptions/Logging/ILogger.cs b/Emuera/_Library/ImageProcessor/Common/Exceptions/Logging/ILogger.cs
deleted file mode 100644
index bc79915..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Exceptions/QuantizationException.cs b/Emuera/_Library/ImageProcessor/Common/Exceptions/QuantizationException.cs
deleted file mode 100644
index 538631a..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Extensions/AssemblyExtensions.cs b/Emuera/_Library/ImageProcessor/Common/Extensions/AssemblyExtensions.cs
deleted file mode 100644
index e70ba9a..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Extensions/DoubleExtensions.cs b/Emuera/_Library/ImageProcessor/Common/Extensions/DoubleExtensions.cs
deleted file mode 100644
index 5f57a3a..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Extensions/EnumerableExtensions.cs b/Emuera/_Library/ImageProcessor/Common/Extensions/EnumerableExtensions.cs
deleted file mode 100644
index 392f863..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Extensions/FloatExtensions.cs b/Emuera/_Library/ImageProcessor/Common/Extensions/FloatExtensions.cs
deleted file mode 100644
index b706704..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Extensions/ImageExtensions.cs b/Emuera/_Library/ImageProcessor/Common/Extensions/ImageExtensions.cs
deleted file mode 100644
index 288553f..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Extensions/IntegerExtensions.cs b/Emuera/_Library/ImageProcessor/Common/Extensions/IntegerExtensions.cs
deleted file mode 100644
index c040d6b..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Extensions/RectangleExtensions.cs b/Emuera/_Library/ImageProcessor/Common/Extensions/RectangleExtensions.cs
deleted file mode 100644
index fe6cf4b..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Helpers/IOHelper.cs b/Emuera/_Library/ImageProcessor/Common/Helpers/IOHelper.cs
deleted file mode 100644
index d0d8024..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Helpers/TypeFinder.cs b/Emuera/_Library/ImageProcessor/Common/Helpers/TypeFinder.cs
deleted file mode 100644
index d3e81cd..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Helpers/UpgradeableReadLock.cs b/Emuera/_Library/ImageProcessor/Common/Helpers/UpgradeableReadLock.cs
deleted file mode 100644
index fa57797..0000000
diff --git a/Emuera/_Library/ImageProcessor/Common/Helpers/WriteLock.cs b/Emuera/_Library/ImageProcessor/Common/Helpers/WriteLock.cs
deleted file mode 100644
index a18ebb5..0000000
diff --git a/Emuera/_Library/ImageProcessor/Configuration/ImageProcessorBootstrapper.cs b/Emuera/_Library/ImageProcessor/Configuration/ImageProcessorBootstrapper.cs
deleted file mode 100644
index 7607a80..0000000
diff --git a/Emuera/_Library/ImageProcessor/Configuration/NativeBinaryFactory.cs b/Emuera/_Library/ImageProcessor/Configuration/NativeBinaryFactory.cs
deleted file mode 100644
index 04000ef..0000000
diff --git a/Emuera/_Library/ImageProcessor/Configuration/NativeMethods.cs b/Emuera/_Library/ImageProcessor/Configuration/NativeMethods.cs
deleted file mode 100644
index 69675bb..0000000
diff --git a/Emuera/_Library/ImageProcessor/ImageFactory.cs b/Emuera/_Library/ImageProcessor/ImageFactory.cs
deleted file mode 100644
index 8837c93..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/AnchorPosition.cs b/Emuera/_Library/ImageProcessor/Imaging/AnchorPosition.cs
deleted file mode 100644
index cb67029..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/AnimationProcessMode.cs b/Emuera/_Library/ImageProcessor/Imaging/AnimationProcessMode.cs
deleted file mode 100644
index 9bae96a..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Colors/CmykColor.cs b/Emuera/_Library/ImageProcessor/Imaging/Colors/CmykColor.cs
deleted file mode 100644
index 5a1f3d8..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Colors/Color32.cs b/Emuera/_Library/ImageProcessor/Imaging/Colors/Color32.cs
deleted file mode 100644
index 0e989c4..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Colors/ColorExtensions.cs b/Emuera/_Library/ImageProcessor/Imaging/Colors/ColorExtensions.cs
deleted file mode 100644
index b9a8026..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Colors/HSLAColor.cs b/Emuera/_Library/ImageProcessor/Imaging/Colors/HSLAColor.cs
deleted file mode 100644
index d47f8eb..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Colors/RGBAColor.cs b/Emuera/_Library/ImageProcessor/Imaging/Colors/RGBAColor.cs
deleted file mode 100644
index defa820..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Colors/RgbaComponent.cs b/Emuera/_Library/ImageProcessor/Imaging/Colors/RgbaComponent.cs
deleted file mode 100644
index 3da1449..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Colors/YCbCrColor.cs b/Emuera/_Library/ImageProcessor/Imaging/Colors/YCbCrColor.cs
deleted file mode 100644
index 957e6ce..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/ComputerArchitectureInfo.cs b/Emuera/_Library/ImageProcessor/Imaging/ComputerArchitectureInfo.cs
deleted file mode 100644
index 6d2b7f7..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Convolution.cs b/Emuera/_Library/ImageProcessor/Imaging/Convolution.cs
deleted file mode 100644
index 60c49e8..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/CropLayer.cs b/Emuera/_Library/ImageProcessor/Imaging/CropLayer.cs
deleted file mode 100644
index 7582201..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/CropMode.cs b/Emuera/_Library/ImageProcessor/Imaging/CropMode.cs
deleted file mode 100644
index 9038ea0..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/FastBitmap.cs b/Emuera/_Library/ImageProcessor/Imaging/FastBitmap.cs
deleted file mode 100644
index d9c2080..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Artistic/HalftoneFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Artistic/HalftoneFilter.cs
deleted file mode 100644
index acd99a3..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Artistic/OilPaintingFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Artistic/OilPaintingFilter.cs
deleted file mode 100644
index cd611b9..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Binarization/BinaryThreshold.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Binarization/BinaryThreshold.cs
deleted file mode 100644
index 5eca746..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/ConvolutionFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/ConvolutionFilter.cs
deleted file mode 100644
index a515c89..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/I2DEdgeFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/I2DEdgeFilter.cs
deleted file mode 100644
index 711a283..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/IEdgeFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/IEdgeFilter.cs
deleted file mode 100644
index 7d690e4..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/KayyaliEdgeFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/KayyaliEdgeFilter.cs
deleted file mode 100644
index 2a2e823..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/KirschEdgeFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/KirschEdgeFilter.cs
deleted file mode 100644
index a471739..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/Laplacian3X3EdgeFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/Laplacian3X3EdgeFilter.cs
deleted file mode 100644
index 404a6dd..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/Laplacian5X5EdgeFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/Laplacian5X5EdgeFilter.cs
deleted file mode 100644
index f4ca5e5..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/LaplacianOfGaussianEdgeFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/LaplacianOfGaussianEdgeFilter.cs
deleted file mode 100644
index 336fd8c..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/PrewittEdgeFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/PrewittEdgeFilter.cs
deleted file mode 100644
index 353b43a..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/RobertsCrossEdgeFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/RobertsCrossEdgeFilter.cs
deleted file mode 100644
index 8f6d850..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/ScharrEdgeFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/ScharrEdgeFilter.cs
deleted file mode 100644
index bfb0255..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/SobelEdgeFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/EdgeDetection/SobelEdgeFilter.cs
deleted file mode 100644
index f8c3709..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/Class1.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/Class1.cs
deleted file mode 100644
index 6597c73..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/EmbeddedHaarCascades.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/EmbeddedHaarCascades.cs
deleted file mode 100644
index d59a641..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/GroupMatching.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/GroupMatching.cs
deleted file mode 100644
index 9cb79cc..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarCascade.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarCascade.cs
deleted file mode 100644
index 1d0ff06..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarCascadeSerializationObject.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarCascadeSerializationObject.cs
deleted file mode 100644
index 765bae6..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarCascadeStage.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarCascadeStage.cs
deleted file mode 100644
index a9d51db..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarCascadeWriter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarCascadeWriter.cs
deleted file mode 100644
index ef3f76b..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarClassifier.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarClassifier.cs
deleted file mode 100644
index e5e3b05..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarFeature.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarFeature.cs
deleted file mode 100644
index 09e33b0..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarFeatureNode.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarFeatureNode.cs
deleted file mode 100644
index e81004f..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarRectangle.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarCascade/HaarRectangle.cs
deleted file mode 100644
index dd48898..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarObjectDetector.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/HaarObjectDetector.cs
deleted file mode 100644
index 674495d..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/ObjectDetectorScalingMode.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/ObjectDetectorScalingMode.cs
deleted file mode 100644
index 6da13b4..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/ObjectDetectorSearchMode.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/ObjectDetectorSearchMode.cs
deleted file mode 100644
index 20d2725..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/RectangleGroupMatching.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/RectangleGroupMatching.cs
deleted file mode 100644
index bc2bd10..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/Resources/haarcascade_frontalface_alt.xml b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/Resources/haarcascade_frontalface_alt.xml
deleted file mode 100644
index b3860ad..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/Resources/haarcascade_frontalface_default.xml b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/Resources/haarcascade_frontalface_default.xml
deleted file mode 100644
index bc2aa3c..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/Resources/haarcascade_frontalface_legacy.xml b/Emuera/_Library/ImageProcessor/Imaging/Filters/ObjectDetection/Resources/haarcascade_frontalface_legacy.xml
deleted file mode 100644
index eb6792a..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/BlackWhiteMatrixFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/BlackWhiteMatrixFilter.cs
deleted file mode 100644
index 0c1d8ed..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/ColorMatrixes.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/ColorMatrixes.cs
deleted file mode 100644
index b7bb152..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/ComicMatrixFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/ComicMatrixFilter.cs
deleted file mode 100644
index d8cf44e..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/GothamMatrixFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/GothamMatrixFilter.cs
deleted file mode 100644
index 7bf447e..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/GreyScaleMatrixFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/GreyScaleMatrixFilter.cs
deleted file mode 100644
index b3dd993..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/HiSatchMatrixFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/HiSatchMatrixFilter.cs
deleted file mode 100644
index f4d76db..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/IMatrixFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/IMatrixFilter.cs
deleted file mode 100644
index 1f8541f..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/InvertMatrixFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/InvertMatrixFilter.cs
deleted file mode 100644
index 8b4395c..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/LoSatchMatrixFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/LoSatchMatrixFilter.cs
deleted file mode 100644
index ec3a92c..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/LomographMatrixFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/LomographMatrixFilter.cs
deleted file mode 100644
index 9ea380c..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/MatrixFilterBase.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/MatrixFilterBase.cs
deleted file mode 100644
index 7c37cb4..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/MatrixFilters.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/MatrixFilters.cs
deleted file mode 100644
index 0db1159..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/PolaroidMatrixFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/PolaroidMatrixFilter.cs
deleted file mode 100644
index 72648c0..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/SepiaMatrixFilter.cs b/Emuera/_Library/ImageProcessor/Imaging/Filters/Photo/SepiaMatrixFilter.cs
deleted file mode 100644
index 4b265f4..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/BitmapFormat.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/BitmapFormat.cs
deleted file mode 100644
index 1c31603..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/FormatBase.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/FormatBase.cs
deleted file mode 100644
index 4651b86..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/FormatUtilities.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/FormatUtilities.cs
deleted file mode 100644
index 5f692f9..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/GifDecoder.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/GifDecoder.cs
deleted file mode 100644
index cadebf1..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/GifEncoder.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/GifEncoder.cs
deleted file mode 100644
index 08ce995..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/GifFormat.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/GifFormat.cs
deleted file mode 100644
index 3b80788..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/GifFrame.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/GifFrame.cs
deleted file mode 100644
index 06feb91..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/IAnimatedImageFormat.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/IAnimatedImageFormat.cs
deleted file mode 100644
index 8817a60..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/IQuantizableImageFormat.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/IQuantizableImageFormat.cs
deleted file mode 100644
index 42632c9..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/ISupportedImageFormat.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/ISupportedImageFormat.cs
deleted file mode 100644
index ba10990..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/JpegFormat.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/JpegFormat.cs
deleted file mode 100644
index f797985..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/NativeMethods.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/NativeMethods.cs
deleted file mode 100644
index bd0c9d8..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/PngFormat.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/PngFormat.cs
deleted file mode 100644
index d97f326..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/TiffFormat.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/TiffFormat.cs
deleted file mode 100644
index f47a458..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Formats/WebPFormat.cs b/Emuera/_Library/ImageProcessor/Imaging/Formats/WebPFormat.cs
deleted file mode 100644
index 0e3d52d..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/GaussianLayer.cs b/Emuera/_Library/ImageProcessor/Imaging/GaussianLayer.cs
deleted file mode 100644
index 55668d3..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Helpers/Adjustments.cs b/Emuera/_Library/ImageProcessor/Imaging/Helpers/Adjustments.cs
deleted file mode 100644
index 1a42df3..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Helpers/Converters/BigEndianBitConverter.cs b/Emuera/_Library/ImageProcessor/Imaging/Helpers/Converters/BigEndianBitConverter.cs
deleted file mode 100644
index 6a83ac9..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Helpers/Converters/EndianBitConverter.cs b/Emuera/_Library/ImageProcessor/Imaging/Helpers/Converters/EndianBitConverter.cs
deleted file mode 100644
index e62360e..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Helpers/Converters/Endianness.cs b/Emuera/_Library/ImageProcessor/Imaging/Helpers/Converters/Endianness.cs
deleted file mode 100644
index 5e95986..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Helpers/Converters/LittleEndianBitConverter.cs b/Emuera/_Library/ImageProcessor/Imaging/Helpers/Converters/LittleEndianBitConverter.cs
deleted file mode 100644
index afc8702..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Helpers/Effects.cs b/Emuera/_Library/ImageProcessor/Imaging/Helpers/Effects.cs
deleted file mode 100644
index c0b08dc..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Helpers/GraphicsHelper.cs b/Emuera/_Library/ImageProcessor/Imaging/Helpers/GraphicsHelper.cs
deleted file mode 100644
index bc8eac7..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Helpers/ImageMaths.cs b/Emuera/_Library/ImageProcessor/Imaging/Helpers/ImageMaths.cs
deleted file mode 100644
index 8b83362..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Helpers/PixelOperations.cs b/Emuera/_Library/ImageProcessor/Imaging/Helpers/PixelOperations.cs
deleted file mode 100644
index 8847743..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/IComputerArchitectureInfo.cs b/Emuera/_Library/ImageProcessor/Imaging/IComputerArchitectureInfo.cs
deleted file mode 100644
index 94c84cf..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/ImageLayer.cs b/Emuera/_Library/ImageProcessor/Imaging/ImageLayer.cs
deleted file mode 100644
index 578dc04..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Interpolation.cs b/Emuera/_Library/ImageProcessor/Imaging/Interpolation.cs
deleted file mode 100644
index fc5a064..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/MetaData/ExifBitConverter.cs b/Emuera/_Library/ImageProcessor/Imaging/MetaData/ExifBitConverter.cs
deleted file mode 100644
index 4e974c9..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/MetaData/ExifPropertyTag.cs b/Emuera/_Library/ImageProcessor/Imaging/MetaData/ExifPropertyTag.cs
deleted file mode 100644
index d56b5b2..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/MetaData/ExifPropertyTagConstants.cs b/Emuera/_Library/ImageProcessor/Imaging/MetaData/ExifPropertyTagConstants.cs
deleted file mode 100644
index e9e67c4..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/MetaData/ExifPropertyTagType.cs b/Emuera/_Library/ImageProcessor/Imaging/MetaData/ExifPropertyTagType.cs
deleted file mode 100644
index ad29b0f..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/MetaData/ImageFactoryMetaExtensions.cs b/Emuera/_Library/ImageProcessor/Imaging/MetaData/ImageFactoryMetaExtensions.cs
deleted file mode 100644
index 873b639..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/MetaData/Int32Converter.cs b/Emuera/_Library/ImageProcessor/Imaging/MetaData/Int32Converter.cs
deleted file mode 100644
index f799479..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/MetaData/PropertyTagResolutionUnit.cs b/Emuera/_Library/ImageProcessor/Imaging/MetaData/PropertyTagResolutionUnit.cs
deleted file mode 100644
index 3a2b0e9..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/MetaData/Rational.cs b/Emuera/_Library/ImageProcessor/Imaging/MetaData/Rational.cs
deleted file mode 100644
index 4998422..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Quantizers/IQuantizer.cs b/Emuera/_Library/ImageProcessor/Imaging/Quantizers/IQuantizer.cs
deleted file mode 100644
index ccb2272..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Quantizers/OctreeQuantizer.cs b/Emuera/_Library/ImageProcessor/Imaging/Quantizers/OctreeQuantizer.cs
deleted file mode 100644
index c13148e..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Quantizers/Quantizer.cs b/Emuera/_Library/ImageProcessor/Imaging/Quantizers/Quantizer.cs
deleted file mode 100644
index ed8d8c4..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/Box.cs b/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/Box.cs
deleted file mode 100644
index b44f05f..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/ColorMoment.cs b/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/ColorMoment.cs
deleted file mode 100644
index 88f2d10..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/CubeCut.cs b/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/CubeCut.cs
deleted file mode 100644
index ca27c45..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/Histogram.cs b/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/Histogram.cs
deleted file mode 100644
index c5b1ffa..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/IWuQuantizer.cs b/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/IWuQuantizer.cs
deleted file mode 100644
index 3a0603e..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/ImageBuffer.cs b/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/ImageBuffer.cs
deleted file mode 100644
index c9260d5..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/PaletteColorHistory.cs b/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/PaletteColorHistory.cs
deleted file mode 100644
index 8512add..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/PaletteLookup.cs b/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/PaletteLookup.cs
deleted file mode 100644
index a5a0e43..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/WuQuantizer.cs b/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/WuQuantizer.cs
deleted file mode 100644
index f93a76d..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/WuQuantizerBase.cs b/Emuera/_Library/ImageProcessor/Imaging/Quantizers/WuQuantizer/WuQuantizerBase.cs
deleted file mode 100644
index 679a2e3..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/ResizeHelper.cs b/Emuera/_Library/ImageProcessor/Imaging/ResizeHelper.cs
deleted file mode 100644
index 1a726a1..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/ResizeLayer.cs b/Emuera/_Library/ImageProcessor/Imaging/ResizeLayer.cs
deleted file mode 100644
index 94c01d7..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/ResizeMode.cs b/Emuera/_Library/ImageProcessor/Imaging/ResizeMode.cs
deleted file mode 100644
index cd737b8..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/Resizer.cs b/Emuera/_Library/ImageProcessor/Imaging/Resizer.cs
deleted file mode 100644
index 1b53f89..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/RoundedCornerLayer.cs b/Emuera/_Library/ImageProcessor/Imaging/RoundedCornerLayer.cs
deleted file mode 100644
index 69442be..0000000
diff --git a/Emuera/_Library/ImageProcessor/Imaging/TextLayer.cs b/Emuera/_Library/ImageProcessor/Imaging/TextLayer.cs
deleted file mode 100644
index 837299c..0000000
diff --git a/Emuera/_Library/ImageProcessor/MetaDataMode.cs b/Emuera/_Library/ImageProcessor/MetaDataMode.cs
deleted file mode 100644
index 8df42cf..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Alpha.cs b/Emuera/_Library/ImageProcessor/Processors/Alpha.cs
deleted file mode 100644
index 7d02798..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/AutoRotate.cs b/Emuera/_Library/ImageProcessor/Processors/AutoRotate.cs
deleted file mode 100644
index 2b663e4..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Background.cs b/Emuera/_Library/ImageProcessor/Processors/Background.cs
deleted file mode 100644
index b1067e1..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/BackgroundColor.cs b/Emuera/_Library/ImageProcessor/Processors/BackgroundColor.cs
deleted file mode 100644
index f907595..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Brightness.cs b/Emuera/_Library/ImageProcessor/Processors/Brightness.cs
deleted file mode 100644
index 2af2b9e..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Contrast.cs b/Emuera/_Library/ImageProcessor/Processors/Contrast.cs
deleted file mode 100644
index dfa054a..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Crop.cs b/Emuera/_Library/ImageProcessor/Processors/Crop.cs
deleted file mode 100644
index 5523e70..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/DetectEdges.cs b/Emuera/_Library/ImageProcessor/Processors/DetectEdges.cs
deleted file mode 100644
index 778262a..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/DetectObjects.cs b/Emuera/_Library/ImageProcessor/Processors/DetectObjects.cs
deleted file mode 100644
index 417c55a..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/EntropyCrop.cs b/Emuera/_Library/ImageProcessor/Processors/EntropyCrop.cs
deleted file mode 100644
index 8491f2b..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Filter.cs b/Emuera/_Library/ImageProcessor/Processors/Filter.cs
deleted file mode 100644
index cd9b885..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Flip.cs b/Emuera/_Library/ImageProcessor/Processors/Flip.cs
deleted file mode 100644
index 4f4c6d4..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Format.cs b/Emuera/_Library/ImageProcessor/Processors/Format.cs
deleted file mode 100644
index 1efa7aa..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Gamma.cs b/Emuera/_Library/ImageProcessor/Processors/Gamma.cs
deleted file mode 100644
index 4716e00..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/GaussianBlur.cs b/Emuera/_Library/ImageProcessor/Processors/GaussianBlur.cs
deleted file mode 100644
index 3704ef3..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/GaussianSharpen.cs b/Emuera/_Library/ImageProcessor/Processors/GaussianSharpen.cs
deleted file mode 100644
index 5ac46c2..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Halftone.cs b/Emuera/_Library/ImageProcessor/Processors/Halftone.cs
deleted file mode 100644
index ca7cdf5..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Hue.cs b/Emuera/_Library/ImageProcessor/Processors/Hue.cs
deleted file mode 100644
index 9025351..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/IGraphicsProcessor.cs b/Emuera/_Library/ImageProcessor/Processors/IGraphicsProcessor.cs
deleted file mode 100644
index 3928ca3..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Mask.cs b/Emuera/_Library/ImageProcessor/Processors/Mask.cs
deleted file mode 100644
index 76fc10c..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Meta.cs b/Emuera/_Library/ImageProcessor/Processors/Meta.cs
deleted file mode 100644
index d524112..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Overlay.cs b/Emuera/_Library/ImageProcessor/Processors/Overlay.cs
deleted file mode 100644
index 5bdf32a..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Pixelate.cs b/Emuera/_Library/ImageProcessor/Processors/Pixelate.cs
deleted file mode 100644
index 55d84d1..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Quality.cs b/Emuera/_Library/ImageProcessor/Processors/Quality.cs
deleted file mode 100644
index fe52e36..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/ReplaceColor.cs b/Emuera/_Library/ImageProcessor/Processors/ReplaceColor.cs
deleted file mode 100644
index d8f5b14..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Resize.cs b/Emuera/_Library/ImageProcessor/Processors/Resize.cs
deleted file mode 100644
index 91a689a..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Resolution.cs b/Emuera/_Library/ImageProcessor/Processors/Resolution.cs
deleted file mode 100644
index 378bbf7..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Rotate.cs b/Emuera/_Library/ImageProcessor/Processors/Rotate.cs
deleted file mode 100644
index eba48a5..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/RotateBounded.cs b/Emuera/_Library/ImageProcessor/Processors/RotateBounded.cs
deleted file mode 100644
index c7f2273..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/RoundedCorners.cs b/Emuera/_Library/ImageProcessor/Processors/RoundedCorners.cs
deleted file mode 100644
index be350aa..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Saturation.cs b/Emuera/_Library/ImageProcessor/Processors/Saturation.cs
deleted file mode 100644
index acecd37..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Tint.cs b/Emuera/_Library/ImageProcessor/Processors/Tint.cs
deleted file mode 100644
index 4a6422c..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Vignette.cs b/Emuera/_Library/ImageProcessor/Processors/Vignette.cs
deleted file mode 100644
index 663abee..0000000
diff --git a/Emuera/_Library/ImageProcessor/Processors/Watermark.cs b/Emuera/_Library/ImageProcessor/Processors/Watermark.cs
deleted file mode 100644
index 6201620..0000000
diff --git a/Emuera/_Library/ImageProcessor/Resources/Unmanaged/README.txt b/Emuera/_Library/ImageProcessor/Resources/Unmanaged/README.txt
deleted file mode 100644
index 0d05934..0000000
diff --git a/Emuera/_Library/ImageProcessor/Resources/Unmanaged/x64/libwebp.dll b/Emuera/_Library/ImageProcessor/Resources/Unmanaged/x64/libwebp.dll
deleted file mode 100644
index 132187b..0000000
diff --git a/Emuera/_Library/ImageProcessor/Resources/Unmanaged/x86/libwebp.dll b/Emuera/_Library/ImageProcessor/Resources/Unmanaged/x86/libwebp.dll
deleted file mode 100644
index da6b628..0000000
diff --git a/Emuera/_Library/WebPWrapper.cs b/Emuera/_Library/WebPWrapper.cs
new file mode 100644
index 0000000..f21e98f
--- /dev/null
+++ b/Emuera/_Library/WebPWrapper.cs
@@ -0,0 +1,1976 @@
+﻿/////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/// Wrapper for WebP format in C#. (MIT) Jose M. Piñeiro
+///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
+/// Decode Functions:
+/// Bitmap Load(string pathFileName) - Load a WebP file in bitmap.
+/// Bitmap Decode(byte[] rawWebP) - Decode WebP data (rawWebP) to bitmap.
+/// Bitmap Decode(byte[] rawWebP, WebPDecoderOptions options) - Decode WebP data (rawWebP) to bitmap using 'options'.
+/// Bitmap GetThumbnailFast(byte[] rawWebP, int width, int height) - Get a thumbnail from WebP data (rawWebP) with dimensions 'width x height'. Fast mode.
+/// Bitmap GetThumbnailQuality(byte[] rawWebP, int width, int height) - Fast get a thumbnail from WebP data (rawWebP) with dimensions 'width x height'. Quality mode.
+/// 
+/// Encode Functions:
+/// Save(Bitmap bmp, string pathFileName, int quality) - Save bitmap with quality lost to WebP file. Opcionally select 'quality'.
+/// byte[] EncodeLossy(Bitmap bmp, int quality) - Encode bitmap with quality lost to WebP byte array. Opcionally select 'quality'.
+/// byte[] EncodeLossy(Bitmap bmp, int quality, int speed, bool info) - Encode bitmap with quality lost to WebP byte array. Select 'quality', 'speed' and optionally select 'info'.
+/// byte[] EncodeLossless(Bitmap bmp) - Encode bitmap without quality lost to WebP byte array. 
+/// byte[] EncodeLossless(Bitmap bmp, int speed, bool info = false) - Encode bitmap without quality lost to WebP byte array. Select 'speed'. 
+/// byte[] EncodeNearLossless(Bitmap bmp, int quality, int speed = 9, bool info = false) - Encode bitmap with a near lossless method to WebP byte array. Select 'quality', 'speed' and optionally select 'info'.
+/// 
+/// Another functions:
+/// string GetVersion() - Get the library version
+/// GetInfo(byte[] rawWebP, out int width, out int height, out bool has_alpha, out bool has_animation, out string format) - Get information of WEBP data
+/// float[] PictureDistortion(Bitmap source, Bitmap reference, int metric_type) - Get PSNR, SSIM or LSIM distortion metric between two pictures
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////
+using System;
+using System.Drawing;
+using System.Drawing.Imaging;
+using System.IO;
+using System.Runtime.InteropServices;
+using System.Security;
+using System.Windows.Forms;
+
+namespace WebPWrapper
+{
+    public sealed class WebP : IDisposable
+    {
+        private const int WEBP_MAX_DIMENSION = 16383;
+        #region | Public Decode Functions |
+        /// <summary>Read a WebP file</summary>
+        /// <param name="pathFileName">WebP file to load</param>
+        /// <returns>Bitmap with the WebP image</returns>
+        public Bitmap Load(string pathFileName)
+        {
+            try
+            {
+                byte[] rawWebP = File.ReadAllBytes(pathFileName);
+
+                return Decode(rawWebP);
+            }
+            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.Load"); }
+        }
+
+        /// <summary>Decode a WebP image</summary>
+        /// <param name="rawWebP">The data to uncompress</param>
+        /// <returns>Bitmap with the WebP image</returns>
+        public Bitmap Decode(byte[] rawWebP)
+        {
+            Bitmap bmp = null;
+            BitmapData bmpData = null;
+            GCHandle pinnedWebP = GCHandle.Alloc(rawWebP, GCHandleType.Pinned);
+
+            try
+            {
+                //Get image width and height
+                GetInfo(rawWebP, out int imgWidth, out int imgHeight, out bool hasAlpha, out bool hasAnimation, out string format);
+
+                //Create a BitmapData and Lock all pixels to be written
+                if (hasAlpha)
+                    bmp = new Bitmap(imgWidth, imgHeight, PixelFormat.Format32bppArgb);
+                else
+                    bmp = new Bitmap(imgWidth, imgHeight, PixelFormat.Format24bppRgb);
+                bmpData = bmp.LockBits(new Rectangle(0, 0, imgWidth, imgHeight), ImageLockMode.WriteOnly, bmp.PixelFormat);
+
+                //Uncompress the image
+                int outputSize = bmpData.Stride * imgHeight;
+                IntPtr ptrData = pinnedWebP.AddrOfPinnedObject();
+                if (bmp.PixelFormat == PixelFormat.Format24bppRgb)
+                     UnsafeNativeMethods.WebPDecodeBGRInto(ptrData, rawWebP.Length, bmpData.Scan0, outputSize, bmpData.Stride);
+                else
+                     UnsafeNativeMethods.WebPDecodeBGRAInto(ptrData, rawWebP.Length, bmpData.Scan0, outputSize, bmpData.Stride);
+
+                return bmp;
+            }
+            catch (Exception) { throw; }
+            finally
+            {
+                //Unlock the pixels
+                if (bmpData != null)
+                    bmp.UnlockBits(bmpData);
+
+                //Free memory
+                if (pinnedWebP.IsAllocated)
+                    pinnedWebP.Free();
+            }
+        }
+
+        /// <summary>Decode a WebP image</summary>
+        /// <param name="rawWebP">the data to uncompress</param>
+        /// <param name="options">Options for advanced decode</param>
+        /// <returns>Bitmap with the WebP image</returns>
+        public Bitmap Decode(byte[] rawWebP, WebPDecoderOptions options, PixelFormat pixelFormat = PixelFormat.DontCare)
+        {
+            GCHandle pinnedWebP = GCHandle.Alloc(rawWebP, GCHandleType.Pinned);
+            Bitmap bmp = null;
+            BitmapData bmpData = null;
+            VP8StatusCode result;
+            try
+            {
+                WebPDecoderConfig config = new WebPDecoderConfig();
+                if (UnsafeNativeMethods.WebPInitDecoderConfig(ref config) == 0)
+                {
+                    throw new Exception("WebPInitDecoderConfig failed. Wrong version?");
+                }
+                // Read the .webp input file information
+                IntPtr ptrRawWebP = pinnedWebP.AddrOfPinnedObject();
+                int height;
+                int width;
+                if (options.use_scaling == 0)
+                {
+                    result = UnsafeNativeMethods.WebPGetFeatures(ptrRawWebP, rawWebP.Length, ref config.input);
+                    if (result != VP8StatusCode.VP8_STATUS_OK)
+                        throw new Exception("Failed WebPGetFeatures with error " + result);
+
+                    //Test cropping values
+                    if (options.use_cropping == 1)
+                    {
+                        if (options.crop_left + options.crop_width > config.input.Width || options.crop_top + options.crop_height > config.input.Height)
+                            throw new Exception("Crop options exceeded WebP image dimensions");
+                        width = options.crop_width;
+                        height = options.crop_height;
+                    }
+                }
+                else
+                {
+                    width = options.scaled_width;
+                    height = options.scaled_height;
+                }
+
+                config.options.bypass_filtering = options.bypass_filtering;
+                config.options.no_fancy_upsampling = options.no_fancy_upsampling;
+                config.options.use_cropping = options.use_cropping;
+                config.options.crop_left = options.crop_left;
+                config.options.crop_top = options.crop_top;
+                config.options.crop_width = options.crop_width;
+                config.options.crop_height = options.crop_height;
+                config.options.use_scaling = options.use_scaling;
+                config.options.scaled_width = options.scaled_width;
+                config.options.scaled_height = options.scaled_height;
+                config.options.use_threads = options.use_threads;
+                config.options.dithering_strength = options.dithering_strength;
+                config.options.flip = options.flip;
+                config.options.alpha_dithering_strength = options.alpha_dithering_strength;
+
+                //Create a BitmapData and Lock all pixels to be written
+                if (config.input.Has_alpha == 1)
+                {
+                    config.output.colorspace = WEBP_CSP_MODE.MODE_bgrA;
+                    bmp = new Bitmap(config.input.Width, config.input.Height, PixelFormat.Format32bppArgb);
+                }
+                else
+                {
+                    config.output.colorspace = WEBP_CSP_MODE.MODE_BGR;
+                    bmp = new Bitmap(config.input.Width, config.input.Height, PixelFormat.Format24bppRgb);
+                }
+                bmpData = bmp.LockBits(new Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.WriteOnly, bmp.PixelFormat);
+
+                // Specify the output format
+                config.output.u.RGBA.rgba = bmpData.Scan0;
+                config.output.u.RGBA.stride = bmpData.Stride;
+                config.output.u.RGBA.size = (UIntPtr)(bmp.Height * bmpData.Stride);
+                config.output.height = bmp.Height;
+                config.output.width = bmp.Width;
+                config.output.is_external_memory = 1;
+
+                // Decode
+                result = UnsafeNativeMethods.WebPDecode(ptrRawWebP, rawWebP.Length, ref config);
+                if (result != VP8StatusCode.VP8_STATUS_OK)
+                {
+                    throw new Exception("Failed WebPDecode with error " + result);
+                }
+                UnsafeNativeMethods.WebPFreeDecBuffer(ref config.output);
+
+                return bmp;
+            }
+            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.Decode"); }
+            finally
+            {
+                //Unlock the pixels
+                if (bmpData != null)
+                    bmp.UnlockBits(bmpData);
+
+                //Free memory
+                if (pinnedWebP.IsAllocated)
+                    pinnedWebP.Free();
+            }
+        }
+
+        /// <summary>Get Thumbnail from webP in mode faster/low quality</summary>
+        /// <param name="rawWebP">The data to uncompress</param>
+        /// <param name="width">Wanted width of thumbnail</param>
+        /// <param name="height">Wanted height of thumbnail</param>
+        /// <returns>Bitmap with the WebP thumbnail in 24bpp</returns>
+        public Bitmap GetThumbnailFast(byte[] rawWebP, int width, int height)
+        {
+            GCHandle pinnedWebP = GCHandle.Alloc(rawWebP, GCHandleType.Pinned);
+            Bitmap bmp = null;
+            BitmapData bmpData = null;
+
+            try
+            {
+                WebPDecoderConfig config = new WebPDecoderConfig();
+                if (UnsafeNativeMethods.WebPInitDecoderConfig(ref config) == 0)
+                    throw new Exception("WebPInitDecoderConfig failed. Wrong version?");
+
+                // Set up decode options
+                config.options.bypass_filtering = 1;
+                config.options.no_fancy_upsampling = 1;
+                config.options.use_threads = 1;
+                config.options.use_scaling = 1;
+                config.options.scaled_width = width;
+                config.options.scaled_height = height;
+
+                // Create a BitmapData and Lock all pixels to be written
+                bmp = new Bitmap(width, height, PixelFormat.Format24bppRgb);
+                bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.WriteOnly, bmp.PixelFormat);
+
+                // Specify the output format
+                config.output.colorspace = WEBP_CSP_MODE.MODE_BGR;
+                config.output.u.RGBA.rgba = bmpData.Scan0;
+                config.output.u.RGBA.stride = bmpData.Stride;
+                config.output.u.RGBA.size = (UIntPtr)(height * bmpData.Stride);
+                config.output.height = height;
+                config.output.width = width;
+                config.output.is_external_memory = 1;
+
+                // Decode
+                IntPtr ptrRawWebP = pinnedWebP.AddrOfPinnedObject();
+                VP8StatusCode result = UnsafeNativeMethods.WebPDecode(ptrRawWebP, rawWebP.Length, ref config);
+                if (result != VP8StatusCode.VP8_STATUS_OK)
+                    throw new Exception("Failed WebPDecode with error " + result);
+
+                UnsafeNativeMethods.WebPFreeDecBuffer(ref config.output);
+
+                return bmp;
+            }
+            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.Thumbnail"); }
+            finally
+            {
+                //Unlock the pixels
+                if (bmpData != null)
+                    bmp.UnlockBits(bmpData);
+
+                //Free memory
+                if (pinnedWebP.IsAllocated)
+                    pinnedWebP.Free();
+            }
+        }
+
+        /// <summary>Thumbnail from webP in mode slow/high quality</summary>
+        /// <param name="rawWebP">The data to uncompress</param>
+        /// <param name="width">Wanted width of thumbnail</param>
+        /// <param name="height">Wanted height of thumbnail</param>
+        /// <returns>Bitmap with the WebP thumbnail</returns>
+        public Bitmap GetThumbnailQuality(byte[] rawWebP, int width, int height)
+        {
+            GCHandle pinnedWebP = GCHandle.Alloc(rawWebP, GCHandleType.Pinned);
+            Bitmap bmp = null;
+            BitmapData bmpData = null;
+
+            try
+            {
+                WebPDecoderConfig config = new WebPDecoderConfig();
+                if (UnsafeNativeMethods.WebPInitDecoderConfig(ref config) == 0)
+                    throw new Exception("WebPInitDecoderConfig failed. Wrong version?");
+
+                IntPtr ptrRawWebP = pinnedWebP.AddrOfPinnedObject();
+                VP8StatusCode result = UnsafeNativeMethods.WebPGetFeatures(ptrRawWebP, rawWebP.Length, ref config.input);
+                if (result != VP8StatusCode.VP8_STATUS_OK)
+                    throw new Exception("Failed WebPGetFeatures with error " + result);
+
+                // Set up decode options
+                config.options.bypass_filtering = 0;
+                config.options.no_fancy_upsampling = 0;
+                config.options.use_threads = 1;
+                config.options.use_scaling = 1;
+                config.options.scaled_width = width;
+                config.options.scaled_height = height;
+
+                //Create a BitmapData and Lock all pixels to be written
+                if (config.input.Has_alpha == 1)
+                {
+                    config.output.colorspace = WEBP_CSP_MODE.MODE_bgrA;
+                    bmp = new Bitmap(width, height, PixelFormat.Format32bppArgb);
+                }
+                else
+                {
+                    config.output.colorspace = WEBP_CSP_MODE.MODE_BGR;
+                    bmp = new Bitmap(width, height, PixelFormat.Format24bppRgb);
+                }
+                bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.WriteOnly, bmp.PixelFormat);
+
+                // Specify the output format
+                config.output.u.RGBA.rgba = bmpData.Scan0;
+                config.output.u.RGBA.stride = bmpData.Stride;
+                config.output.u.RGBA.size = (UIntPtr)(height * bmpData.Stride);
+                config.output.height = height;
+                config.output.width = width;
+                config.output.is_external_memory = 1;
+
+                // Decode
+                result = UnsafeNativeMethods.WebPDecode(ptrRawWebP, rawWebP.Length, ref config);
+                if (result != VP8StatusCode.VP8_STATUS_OK)
+                    throw new Exception("Failed WebPDecode with error " + result);
+
+                UnsafeNativeMethods.WebPFreeDecBuffer(ref config.output);
+
+                return bmp;
+            }
+            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.Thumbnail"); }
+            finally
+            {
+                //Unlock the pixels
+                if (bmpData != null)
+                    bmp.UnlockBits(bmpData);
+
+                //Free memory
+                if (pinnedWebP.IsAllocated)
+                    pinnedWebP.Free();
+            }
+        }
+        #endregion
+
+        #region | Public Encode Functions |
+        /// <summary>Save bitmap to file in WebP format</summary>
+        /// <param name="bmp">Bitmap with the WebP image</param>
+        /// <param name="pathFileName">The file to write</param>
+        /// <param name="quality">Between 0 (lower quality, lowest file size) and 100 (highest quality, higher file size)</param>
+        public void Save(Bitmap bmp, string pathFileName, int quality = 75)
+        {
+            byte[] rawWebP;
+
+            try
+            {
+                //Encode in webP format
+                rawWebP = EncodeLossy(bmp, quality);
+
+                //Write webP file
+                File.WriteAllBytes(pathFileName, rawWebP);
+            }
+            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.Save"); }
+        }
+
+        /// <summary>Lossy encoding bitmap to WebP (Simple encoding API)</summary>
+        /// <param name="bmp">Bitmap with the image</param>
+        /// <param name="quality">Between 0 (lower quality, lowest file size) and 100 (highest quality, higher file size)</param>
+        /// <returns>Compressed data</returns>
+        public byte[] EncodeLossy(Bitmap bmp, int quality = 75)
+        {
+            //test bmp
+            if (bmp.Width == 0 || bmp.Height == 0)
+                throw new ArgumentException("Bitmap contains no data.", "bmp");
+            if (bmp.Width > WEBP_MAX_DIMENSION || bmp.Height > WEBP_MAX_DIMENSION)
+                throw new NotSupportedException("Bitmap's dimension is too large. Max is " + WEBP_MAX_DIMENSION + "x" + WEBP_MAX_DIMENSION + " pixels.");
+            if (bmp.PixelFormat != PixelFormat.Format24bppRgb && bmp.PixelFormat != PixelFormat.Format32bppArgb)
+                throw new NotSupportedException("Only support Format24bppRgb and Format32bppArgb pixelFormat.");
+
+            BitmapData bmpData = null;
+            IntPtr unmanagedData = IntPtr.Zero;
+
+            try
+            {
+                int size;
+                
+                //Get bmp data
+                bmpData = bmp.LockBits(new Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.ReadOnly, bmp.PixelFormat);
+
+                //Compress the bmp data
+                if (bmp.PixelFormat == PixelFormat.Format24bppRgb)
+                    size = UnsafeNativeMethods.WebPEncodeBGR(bmpData.Scan0, bmp.Width, bmp.Height, bmpData.Stride, quality, out unmanagedData);
+                else
+                    size = UnsafeNativeMethods.WebPEncodeBGRA(bmpData.Scan0, bmp.Width, bmp.Height, bmpData.Stride, quality, out unmanagedData);
+                if (size == 0)
+                    throw new Exception("Can´t encode WebP");
+
+                //Copy image compress data to output array
+                byte[] rawWebP = new byte[size];
+                Marshal.Copy(unmanagedData, rawWebP, 0, size);
+
+                return rawWebP;
+            }
+            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.EncodeLossly"); }
+            finally
+            {
+                //Unlock the pixels
+                if (bmpData != null)
+                    bmp.UnlockBits(bmpData);
+
+                //Free memory
+                if (unmanagedData != IntPtr.Zero)
+                    UnsafeNativeMethods.WebPFree(unmanagedData);
+            }
+        }
+
+        /// <summary>Lossy encoding bitmap to WebP (Advanced encoding API)</summary>
+        /// <param name="bmp">Bitmap with the image</param>
+        /// <param name="quality">Between 0 (lower quality, lowest file size) and 100 (highest quality, higher file size)</param>
+        /// <param name="speed">Between 0 (fastest, lowest compression) and 9 (slower, best compression)</param>
+        /// <returns>Compressed data</returns>
+        public byte[] EncodeLossy(Bitmap bmp, int quality, int speed, bool info = false)
+        {
+            //Initialize configuration structure
+            WebPConfig config = new WebPConfig();
+
+            //Set compression parameters
+            if (UnsafeNativeMethods.WebPConfigInit(ref config, WebPPreset.WEBP_PRESET_DEFAULT, 75) == 0)
+                throw new Exception("Can´t configure preset");
+
+            // Add additional tuning:
+            config.method = speed;
+            if (config.method > 6)
+                config.method = 6;
+            config.quality = quality;
+            config.autofilter = 1;
+            config.pass = speed + 1;
+            config.segments = 4;
+            config.partitions = 3;
+            config.thread_level = 1;
+            config.alpha_quality = quality;
+            config.alpha_filtering = 2;
+            config.use_sharp_yuv = 1;
+
+            if (UnsafeNativeMethods.WebPGetDecoderVersion() > 1082)     //Old version does not support preprocessing 4
+            {
+                config.preprocessing = 4;
+                config.use_sharp_yuv = 1;
+            }
+            else
+                config.preprocessing = 3;
+
+            return AdvancedEncode(bmp, config, info);
+        }
+
+        /// <summary>Lossless encoding bitmap to WebP (Simple encoding API)</summary>
+        /// <param name="bmp">Bitmap with the image</param>
+        /// <returns>Compressed data</returns>
+        public byte[] EncodeLossless(Bitmap bmp)
+        {
+            //test bmp
+            if (bmp.Width == 0 || bmp.Height == 0)
+                throw new ArgumentException("Bitmap contains no data.", "bmp");
+            if (bmp.Width > WEBP_MAX_DIMENSION || bmp.Height > WEBP_MAX_DIMENSION)
+                throw new NotSupportedException("Bitmap's dimension is too large. Max is " + WEBP_MAX_DIMENSION + "x" + WEBP_MAX_DIMENSION + " pixels.");
+            if (bmp.PixelFormat != PixelFormat.Format24bppRgb && bmp.PixelFormat != PixelFormat.Format32bppArgb)
+                throw new NotSupportedException("Only support Format24bppRgb and Format32bppArgb pixelFormat.");
+
+            BitmapData bmpData = null;
+            IntPtr unmanagedData = IntPtr.Zero;
+            try
+            {
+                //Get bmp data
+                bmpData = bmp.LockBits(new Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.ReadOnly, bmp.PixelFormat);
+
+                //Compress the bmp data
+                int size;
+                if (bmp.PixelFormat == PixelFormat.Format24bppRgb)
+                    size = UnsafeNativeMethods.WebPEncodeLosslessBGR(bmpData.Scan0, bmp.Width, bmp.Height, bmpData.Stride, out unmanagedData);
+                else
+                    size = UnsafeNativeMethods.WebPEncodeLosslessBGRA(bmpData.Scan0, bmp.Width, bmp.Height, bmpData.Stride, out unmanagedData);
+
+                //Copy image compress data to output array
+                byte[] rawWebP = new byte[size];
+                Marshal.Copy(unmanagedData, rawWebP, 0, size);
+
+                return rawWebP;
+            }
+            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.EncodeLossless (Simple)"); }
+            finally
+            {
+                //Unlock the pixels
+                if (bmpData != null)
+                    bmp.UnlockBits(bmpData);
+
+                //Free memory
+                if (unmanagedData != IntPtr.Zero)
+                    UnsafeNativeMethods.WebPFree(unmanagedData);
+            }
+        }
+
+        /// <summary>Lossless encoding image in bitmap (Advanced encoding API)</summary>
+        /// <param name="bmp">Bitmap with the image</param>
+        /// <param name="speed">Between 0 (fastest, lowest compression) and 9 (slower, best compression)</param>
+        /// <returns>Compressed data</returns>
+        public byte[] EncodeLossless(Bitmap bmp, int speed)
+        {
+            //Initialize configuration structure
+            WebPConfig config = new WebPConfig();
+
+            //Set compression parameters
+            if (UnsafeNativeMethods.WebPConfigInit(ref config, WebPPreset.WEBP_PRESET_DEFAULT, (speed + 1) * 10) == 0)
+                throw new Exception("Can´t config preset");
+
+            //Old version of DLL does not support info and WebPConfigLosslessPreset
+            if (UnsafeNativeMethods.WebPGetDecoderVersion() > 1082)
+            {
+                if (UnsafeNativeMethods.WebPConfigLosslessPreset(ref config, speed) == 0)
+                    throw new Exception("Can´t configure lossless preset");
+            }
+            else
+            {
+                config.lossless = 1;
+                config.method = speed;
+                if (config.method > 6)
+                    config.method = 6;
+                config.quality = (speed + 1) * 10;
+            }
+            config.pass = speed + 1;
+            config.thread_level = 1;
+            config.alpha_filtering = 2;
+            config.use_sharp_yuv = 1;
+            config.exact = 0;
+
+            return AdvancedEncode(bmp, config, false);
+        }
+
+        /// <summary>Near lossless encoding image in bitmap</summary>
+        /// <param name="bmp">Bitmap with the image</param>
+        /// <param name="quality">Between 0 (lower quality, lowest file size) and 100 (highest quality, higher file size)</param>
+        /// <param name="speed">Between 0 (fastest, lowest compression) and 9 (slower, best compression)</param>
+        /// <returns>Compress data</returns>
+        public byte[] EncodeNearLossless(Bitmap bmp, int quality, int speed = 9)
+        {
+            //test DLL version
+            if (UnsafeNativeMethods.WebPGetDecoderVersion() <= 1082)
+                throw new Exception("This DLL version not support EncodeNearLossless");
+
+            //Inicialize config struct
+            WebPConfig config = new WebPConfig();
+
+            //Set compression parameters
+            if (UnsafeNativeMethods.WebPConfigInit(ref config, WebPPreset.WEBP_PRESET_DEFAULT, (speed + 1) * 10) == 0)
+                throw new Exception("Can´t configure preset");
+            if (UnsafeNativeMethods.WebPConfigLosslessPreset(ref config, speed) == 0)
+                throw new Exception("Can´t configure lossless preset");
+            config.pass = speed + 1;
+            config.near_lossless = quality;
+            config.thread_level = 1;
+            config.alpha_filtering = 2;
+            config.use_sharp_yuv = 1;
+            config.exact = 0;
+
+            return AdvancedEncode(bmp, config, false);
+        }
+        #endregion
+
+        #region | Another Public Functions |
+        /// <summary>Get the libwebp version</summary>
+        /// <returns>Version of library</returns>
+        public string GetVersion()
+        {
+            try
+            {
+                uint v = (uint)UnsafeNativeMethods.WebPGetDecoderVersion();
+                var revision = v % 256;
+                var minor = (v >> 8) % 256;
+                var major = (v >> 16) % 256;
+                return major + "." + minor + "." + revision;
+            }
+            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.GetVersion"); }
+        }
+
+        /// <summary>Get info of WEBP data</summary>
+        /// <param name="rawWebP">The data of WebP</param>
+        /// <param name="width">width of image</param>
+        /// <param name="height">height of image</param>
+        /// <param name="has_alpha">Image has alpha channel</param>
+        /// <param name="has_animation">Image is a animation</param>
+        /// <param name="format">Format of image: 0 = undefined (/mixed), 1 = lossy, 2 = lossless</param>
+        public void GetInfo(byte[] rawWebP, out int width, out int height, out bool has_alpha, out bool has_animation, out string format)
+        {
+            VP8StatusCode result;
+            GCHandle pinnedWebP = GCHandle.Alloc(rawWebP, GCHandleType.Pinned);
+
+            try
+            {
+                IntPtr ptrRawWebP = pinnedWebP.AddrOfPinnedObject();
+
+                WebPBitstreamFeatures features = new WebPBitstreamFeatures();
+                result = UnsafeNativeMethods.WebPGetFeatures(ptrRawWebP, rawWebP.Length, ref features);
+
+                if (result != 0)
+                    throw new Exception(result.ToString());
+
+                width = features.Width;
+                height = features.Height;
+                if (features.Has_alpha == 1) has_alpha = true; else has_alpha = false;
+                if (features.Has_animation == 1) has_animation = true; else has_animation = false;
+                switch (features.Format)
+                {
+                    case 1:
+                        format = "lossy";
+                        break;
+                    case 2:
+                        format = "lossless";
+                        break;
+                    default:
+                        format = "undefined";
+                        break;
+                }
+            }
+            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.GetInfo"); }
+            finally
+            {
+                //Free memory
+                if (pinnedWebP.IsAllocated)
+                    pinnedWebP.Free();
+            }
+        }
+
+        /// <summary>Compute PSNR, SSIM or LSIM distortion metric between two pictures. Warning: this function is rather CPU-intensive</summary>
+        /// <param name="source">Picture to measure</param>
+        /// <param name="reference">Reference picture</param>
+        /// <param name="metric_type">0 = PSNR, 1 = SSIM, 2 = LSIM</param>
+        /// <returns>dB in the Y/U/V/Alpha/All order</returns>
+        public float[] GetPictureDistortion(Bitmap source, Bitmap reference, int metric_type)
+        {
+            WebPPicture wpicSource = new WebPPicture();
+            WebPPicture wpicReference = new WebPPicture();
+            BitmapData sourceBmpData = null;
+            BitmapData referenceBmpData = null;
+            float[] result = new float[5];
+            GCHandle pinnedResult = GCHandle.Alloc(result, GCHandleType.Pinned);
+
+            try
+            {
+                if (source == null)
+                    throw new Exception("Source picture is void");
+                if (reference == null)
+                    throw new Exception("Reference picture is void");
+                if (metric_type > 2)
+                    throw new Exception("Bad metric_type. Use 0 = PSNR, 1 = SSIM, 2 = LSIM");
+                if (source.Width != reference.Width || source.Height != reference.Height)
+                    throw new Exception("Source and Reference pictures have different dimensions");
+
+                // Setup the source picture data, allocating the bitmap, width and height
+                sourceBmpData = source.LockBits(new Rectangle(0, 0, source.Width, source.Height), ImageLockMode.ReadOnly, source.PixelFormat);
+                wpicSource = new WebPPicture();
+                if (UnsafeNativeMethods.WebPPictureInitInternal(ref wpicSource) != 1)
+                    throw new Exception("Can´t initialize WebPPictureInit");
+                wpicSource.width = (int)source.Width;
+                wpicSource.height = (int)source.Height;
+
+                //Put the source bitmap componets in wpic
+                if (sourceBmpData.PixelFormat == PixelFormat.Format32bppArgb)
+                {
+                    wpicSource.use_argb = 1;
+                    if (UnsafeNativeMethods.WebPPictureImportBGRA(ref wpicSource, sourceBmpData.Scan0, sourceBmpData.Stride) != 1)
+                        throw new Exception("Can´t allocate memory in WebPPictureImportBGR");
+                }
+                else
+                {
+                    wpicSource.use_argb = 0;
+                    if (UnsafeNativeMethods.WebPPictureImportBGR(ref wpicSource, sourceBmpData.Scan0, sourceBmpData.Stride) != 1)
+                        throw new Exception("Can´t allocate memory in WebPPictureImportBGR");
+                }
+
+                // Setup the reference picture data, allocating the bitmap, width and height
+                referenceBmpData = reference.LockBits(new Rectangle(0, 0, reference.Width, reference.Height), ImageLockMode.ReadOnly, reference.PixelFormat);
+                wpicReference = new WebPPicture();
+                if (UnsafeNativeMethods.WebPPictureInitInternal(ref wpicReference) != 1)
+                    throw new Exception("Can´t initialize WebPPictureInit");
+                wpicReference.width = (int)reference.Width;
+                wpicReference.height = (int)reference.Height;
+                wpicReference.use_argb = 1;
+
+                //Put the source bitmap contents in WebPPicture instance
+                if (sourceBmpData.PixelFormat == PixelFormat.Format32bppArgb)
+                {
+                    wpicSource.use_argb = 1;
+                    if (UnsafeNativeMethods.WebPPictureImportBGRA(ref wpicReference, referenceBmpData.Scan0, referenceBmpData.Stride) != 1)
+                        throw new Exception("Can´t allocate memory in WebPPictureImportBGR");
+                }
+                else
+                {
+                    wpicSource.use_argb = 0;
+                    if (UnsafeNativeMethods.WebPPictureImportBGR(ref wpicReference, referenceBmpData.Scan0, referenceBmpData.Stride) != 1)
+                        throw new Exception("Can´t allocate memory in WebPPictureImportBGR");
+                }
+
+                //Measure
+                IntPtr ptrResult = pinnedResult.AddrOfPinnedObject();
+                if (UnsafeNativeMethods.WebPPictureDistortion(ref wpicSource, ref wpicReference, metric_type, ptrResult) != 1)
+                    throw new Exception("Can´t measure.");
+                return result;
+            }
+            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.GetPictureDistortion"); }
+            finally
+            {
+                //Unlock the pixels
+                if (sourceBmpData != null)
+                    source.UnlockBits(sourceBmpData);
+                if (referenceBmpData != null)
+                    reference.UnlockBits(referenceBmpData);
+
+                //Free memory
+                if (wpicSource.argb != IntPtr.Zero)
+                    UnsafeNativeMethods.WebPPictureFree(ref wpicSource);
+                if (wpicReference.argb != IntPtr.Zero)
+                    UnsafeNativeMethods.WebPPictureFree(ref wpicReference);
+                //Free memory
+                if (pinnedResult.IsAllocated)
+                    pinnedResult.Free();
+            }
+        }
+        #endregion
+
+        #region | Private Methods |
+        /// <summary>Encoding image  using Advanced encoding API</summary>
+        /// <param name="bmp">Bitmap with the image</param>
+        /// <param name="config">Configuration for encode</param>
+        /// <param name="info">True if need encode info.</param>
+        /// <returns>Compressed data</returns>
+        private byte[] AdvancedEncode(Bitmap bmp, WebPConfig config, bool info)
+        {
+            byte[] rawWebP = null;
+            byte[] dataWebp = null;
+            WebPPicture wpic = new WebPPicture();
+            BitmapData bmpData = null;
+            WebPAuxStats stats = new WebPAuxStats();
+            IntPtr ptrStats = IntPtr.Zero;
+            GCHandle pinnedArrayHandle = new GCHandle();
+            int dataWebpSize;
+            try
+            {
+                //Validate the configuration
+                if (UnsafeNativeMethods.WebPValidateConfig(ref config) != 1)
+                    throw new Exception("Bad configuration parameters");
+
+                //test bmp
+                if (bmp.Width == 0 || bmp.Height == 0)
+                    throw new ArgumentException("Bitmap contains no data.", "bmp");
+                if (bmp.Width > WEBP_MAX_DIMENSION || bmp.Height > WEBP_MAX_DIMENSION)
+                    throw new NotSupportedException("Bitmap's dimension is too large. Max is " + WEBP_MAX_DIMENSION + "x" + WEBP_MAX_DIMENSION + " pixels.");
+                if (bmp.PixelFormat != PixelFormat.Format24bppRgb && bmp.PixelFormat != PixelFormat.Format32bppArgb)
+                    throw new NotSupportedException("Only support Format24bppRgb and Format32bppArgb pixelFormat.");
+
+                // Setup the input data, allocating a the bitmap, width and height
+                bmpData = bmp.LockBits(new Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.ReadOnly, bmp.PixelFormat);
+                if (UnsafeNativeMethods.WebPPictureInitInternal(ref wpic) != 1)
+                    throw new Exception("Can´t initialize WebPPictureInit");
+                wpic.width = (int)bmp.Width;
+                wpic.height = (int)bmp.Height;
+                wpic.use_argb = 1;
+
+                if (bmp.PixelFormat == PixelFormat.Format32bppArgb)
+                {
+                    //Put the bitmap componets in wpic
+                    int result = UnsafeNativeMethods.WebPPictureImportBGRA(ref wpic, bmpData.Scan0, bmpData.Stride);
+                    if (result != 1)
+                        throw new Exception("Can´t allocate memory in WebPPictureImportBGRA");
+                    wpic.colorspace = (uint)WEBP_CSP_MODE.MODE_bgrA;
+                    dataWebpSize = bmp.Width * bmp.Height * 32;
+                    dataWebp = new byte[bmp.Width * bmp.Height * 32];                //Memory for WebP output
+                }
+                else
+                {
+                    //Put the bitmap contents in WebPPicture instance
+                    int result = UnsafeNativeMethods.WebPPictureImportBGR(ref wpic, bmpData.Scan0, bmpData.Stride);
+                    if (result != 1)
+                        throw new Exception("Can´t allocate memory in WebPPictureImportBGR");
+                    dataWebpSize = bmp.Width * bmp.Height * 24;
+
+                }
+
+                //Set up statistics of compression
+                if (info)
+                {
+                    stats = new WebPAuxStats();
+                    ptrStats = Marshal.AllocHGlobal(Marshal.SizeOf(stats));
+                    Marshal.StructureToPtr(stats, ptrStats, false);
+                    wpic.stats = ptrStats;
+                }
+
+                //Memory for WebP output
+                if (dataWebpSize > 2147483591)
+                    dataWebpSize = 2147483591;
+                dataWebp = new byte[bmp.Width * bmp.Height * 32];
+                pinnedArrayHandle = GCHandle.Alloc(dataWebp, GCHandleType.Pinned);
+                IntPtr initPtr = pinnedArrayHandle.AddrOfPinnedObject();
+                wpic.custom_ptr = initPtr;
+
+                //Set up a byte-writing method (write-to-memory, in this case)
+                UnsafeNativeMethods.OnCallback = new UnsafeNativeMethods.WebPMemoryWrite(MyWriter);
+                wpic.writer = Marshal.GetFunctionPointerForDelegate(UnsafeNativeMethods.OnCallback);
+
+                //compress the input samples
+                if (UnsafeNativeMethods.WebPEncode(ref config, ref wpic) != 1)
+                    throw new Exception("Encoding error: " + ((WebPEncodingError)wpic.error_code).ToString());
+
+                //Remove OnCallback
+                UnsafeNativeMethods.OnCallback = null;
+
+                //Unlock the pixels
+                bmp.UnlockBits(bmpData);
+                bmpData = null;
+
+                //Copy webpData to rawWebP
+                int size = (int)((long)wpic.custom_ptr - (long)initPtr);
+                rawWebP = new byte[size];
+                Array.Copy(dataWebp, rawWebP, size);
+
+                //Remove compression data
+                pinnedArrayHandle.Free();
+                dataWebp = null;
+
+                //Show statistics
+                if (info)
+                {
+                    stats = (WebPAuxStats)Marshal.PtrToStructure(ptrStats, typeof(WebPAuxStats));
+                    MessageBox.Show("Dimension: " + wpic.width + " x " + wpic.height + " pixels\n" +
+                                    "Output:    " + stats.coded_size + " bytes\n" +
+                                    "PSNR Y:    " + stats.PSNRY + " db\n" +
+                                    "PSNR u:    " + stats.PSNRU + " db\n" +
+                                    "PSNR v:    " + stats.PSNRV + " db\n" +
+                                    "PSNR ALL:  " + stats.PSNRALL + " db\n" +
+                                    "Block intra4:  " + stats.block_count_intra4 + "\n" +
+                                    "Block intra16: " + stats.block_count_intra16 + "\n" +
+                                    "Block skipped: " + stats.block_count_skipped + "\n" +
+                                    "Header size:    " + stats.header_bytes + " bytes\n" +
+                                    "Mode-partition: " + stats.mode_partition_0 + " bytes\n" +
+                                    "Macro-blocks 0: " + stats.segment_size_segments0 + " residuals bytes\n" +
+                                    "Macro-blocks 1: " + stats.segment_size_segments1 + " residuals bytes\n" +
+                                    "Macro-blocks 2: " + stats.segment_size_segments2 + " residuals bytes\n" +
+                                    "Macro-blocks 3: " + stats.segment_size_segments3 + " residuals bytes\n" +
+                                    "Quantizer    0: " + stats.segment_quant_segments0 + " residuals bytes\n" +
+                                    "Quantizer    1: " + stats.segment_quant_segments1 + " residuals bytes\n" +
+                                    "Quantizer    2: " + stats.segment_quant_segments2 + " residuals bytes\n" +
+                                    "Quantizer    3: " + stats.segment_quant_segments3 + " residuals bytes\n" +
+                                    "Filter level 0: " + stats.segment_level_segments0 + " residuals bytes\n" +
+                                    "Filter level 1: " + stats.segment_level_segments1 + " residuals bytes\n" +
+                                    "Filter level 2: " + stats.segment_level_segments2 + " residuals bytes\n" +
+                                    "Filter level 3: " + stats.segment_level_segments3 + " residuals bytes\n", "Compression statistics");
+                }
+
+                return rawWebP;
+            }
+            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.AdvancedEncode"); }
+            finally
+            {
+                //Free temporal compress memory
+                if (pinnedArrayHandle.IsAllocated)
+                {
+                    pinnedArrayHandle.Free();
+                }
+
+                //Free statistics memory
+                if (ptrStats != IntPtr.Zero)
+                {
+                    Marshal.FreeHGlobal(ptrStats);
+                }
+
+                //Unlock the pixels
+                if (bmpData != null)
+                {
+                    bmp.UnlockBits(bmpData);
+                }
+
+                //Free memory
+                if (wpic.argb != IntPtr.Zero)
+                {
+                    UnsafeNativeMethods.WebPPictureFree(ref wpic);
+                }
+            }
+        }
+
+        private int MyWriter([InAttribute()] IntPtr data, UIntPtr data_size, ref WebPPicture picture)
+        {
+            UnsafeNativeMethods.CopyMemory(picture.custom_ptr, data, (uint)data_size);
+            //picture.custom_ptr = IntPtr.Add(picture.custom_ptr, (int)data_size);   //Only in .NET > 4.0
+            picture.custom_ptr = new IntPtr(picture.custom_ptr.ToInt64() + (int)data_size);
+            return 1;
+        }
+
+        private delegate int MyWriterDelegate([InAttribute()] IntPtr data, UIntPtr data_size, ref WebPPicture picture);
+        #endregion
+
+        #region | Destruction |
+        /// <summary>Free memory</summary>
+        public void Dispose()
+        {
+            GC.SuppressFinalize(this);
+        }
+        #endregion
+    }
+
+    #region | Import libwebp functions |
+    [SuppressUnmanagedCodeSecurityAttribute]
+    internal sealed partial class UnsafeNativeMethods
+    {
+
+        [DllImport("kernel32.dll", EntryPoint = "CopyMemory", SetLastError = false)]
+        internal static extern void CopyMemory(IntPtr dest, IntPtr src, uint count);
+
+        private static readonly int WEBP_DECODER_ABI_VERSION = 0x0208;
+
+        /// <summary>This function will initialize the configuration according to a predefined set of parameters (referred to by 'preset') and a given quality factor</summary>
+        /// <param name="config">The WebPConfig structure</param>
+        /// <param name="preset">Type of image</param>
+        /// <param name="quality">Quality of compression</param>
+        /// <returns>0 if error</returns>
+        internal static int WebPConfigInit(ref WebPConfig config, WebPPreset preset, float quality)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPConfigInitInternal_x86(ref config, preset, quality, WEBP_DECODER_ABI_VERSION);
+                case 8:
+                    return WebPConfigInitInternal_x64(ref config, preset, quality, WEBP_DECODER_ABI_VERSION);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPConfigInitInternal")]
+        private static extern int WebPConfigInitInternal_x86(ref WebPConfig config, WebPPreset preset, float quality, int WEBP_DECODER_ABI_VERSION);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPConfigInitInternal")]
+        private static extern int WebPConfigInitInternal_x64(ref WebPConfig config, WebPPreset preset, float quality, int WEBP_DECODER_ABI_VERSION);
+
+        /// <summary>Get info of WepP image</summary>
+        /// <param name="rawWebP">Bytes[] of WebP image</param>
+        /// <param name="data_size">Size of rawWebP</param>
+        /// <param name="features">Features of WebP image</param>
+        /// <returns>VP8StatusCode</returns>
+        internal static VP8StatusCode WebPGetFeatures(IntPtr rawWebP, int data_size, ref WebPBitstreamFeatures features)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPGetFeaturesInternal_x86(rawWebP, (UIntPtr)data_size, ref features, WEBP_DECODER_ABI_VERSION);
+                case 8:
+                    return WebPGetFeaturesInternal_x64(rawWebP, (UIntPtr)data_size, ref features, WEBP_DECODER_ABI_VERSION);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPGetFeaturesInternal")]
+        private static extern VP8StatusCode WebPGetFeaturesInternal_x86([InAttribute()] IntPtr rawWebP, UIntPtr data_size, ref WebPBitstreamFeatures features, int WEBP_DECODER_ABI_VERSION);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPGetFeaturesInternal")]
+        private static extern VP8StatusCode WebPGetFeaturesInternal_x64([InAttribute()] IntPtr rawWebP, UIntPtr data_size, ref WebPBitstreamFeatures features, int WEBP_DECODER_ABI_VERSION);
+
+        /// <summary>Activate the lossless compression mode with the desired efficiency</summary>
+        /// <param name="config">The WebPConfig struct</param>
+        /// <param name="level">between 0 (fastest, lowest compression) and 9 (slower, best compression)</param>
+        /// <returns>0 in case of parameter error</returns>
+        internal static int WebPConfigLosslessPreset(ref WebPConfig config, int level)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPConfigLosslessPreset_x86(ref config, level);
+                case 8:
+                    return WebPConfigLosslessPreset_x64(ref config, level);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPConfigLosslessPreset")]
+        private static extern int WebPConfigLosslessPreset_x86(ref WebPConfig config, int level);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPConfigLosslessPreset")]
+        private static extern int WebPConfigLosslessPreset_x64(ref WebPConfig config, int level);
+
+        /// <summary>Check that configuration is non-NULL and all configuration parameters are within their valid ranges</summary>
+        /// <param name="config">The WebPConfig structure</param>
+        /// <returns>1 if configuration is OK</returns>
+        internal static int WebPValidateConfig(ref WebPConfig config)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPValidateConfig_x86(ref config);
+                case 8:
+                    return WebPValidateConfig_x64(ref config);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPValidateConfig")]
+        private static extern int WebPValidateConfig_x86(ref WebPConfig config);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPValidateConfig")]
+        private static extern int WebPValidateConfig_x64(ref WebPConfig config);
+
+        /// <summary>Initialize the WebPPicture structure checking the DLL version</summary>
+        /// <param name="wpic">The WebPPicture structure</param>
+        /// <returns>1 if not error</returns>
+        internal static int WebPPictureInitInternal(ref WebPPicture wpic)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPPictureInitInternal_x86(ref wpic, WEBP_DECODER_ABI_VERSION);
+                case 8:
+                    return WebPPictureInitInternal_x64(ref wpic, WEBP_DECODER_ABI_VERSION);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureInitInternal")]
+        private static extern int WebPPictureInitInternal_x86(ref WebPPicture wpic, int WEBP_DECODER_ABI_VERSION);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureInitInternal")]
+        private static extern int WebPPictureInitInternal_x64(ref WebPPicture wpic, int WEBP_DECODER_ABI_VERSION);
+
+        /// <summary>Colorspace conversion function to import RGB samples</summary>
+        /// <param name="wpic">The WebPPicture structure</param>
+        /// <param name="bgr">Point to BGR data</param>
+        /// <param name="stride">stride of BGR data</param>
+        /// <returns>Returns 0 in case of memory error.</returns>
+        internal static int WebPPictureImportBGR(ref WebPPicture wpic, IntPtr bgr, int stride)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPPictureImportBGR_x86(ref wpic, bgr, stride);
+                case 8:
+                    return WebPPictureImportBGR_x64(ref wpic, bgr, stride);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureImportBGR")]
+        private static extern int WebPPictureImportBGR_x86(ref WebPPicture wpic, IntPtr bgr, int stride);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureImportBGR")]
+        private static extern int WebPPictureImportBGR_x64(ref WebPPicture wpic, IntPtr bgr, int stride);
+
+        /// <summary>Color-space conversion function to import RGB samples</summary>
+        /// <param name="wpic">The WebPPicture structure</param>
+        /// <param name="bgra">Point to BGRA data</param>
+        /// <param name="stride">stride of BGRA data</param>
+        /// <returns>Returns 0 in case of memory error.</returns>
+        internal static int WebPPictureImportBGRA(ref WebPPicture wpic, IntPtr bgra, int stride)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPPictureImportBGRA_x86(ref wpic, bgra, stride);
+                case 8:
+                    return WebPPictureImportBGRA_x64(ref wpic, bgra, stride);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureImportBGRA")]
+        private static extern int WebPPictureImportBGRA_x86(ref WebPPicture wpic, IntPtr bgra, int stride);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureImportBGRA")]
+        private static extern int WebPPictureImportBGRA_x64(ref WebPPicture wpic, IntPtr bgra, int stride);
+
+        /// <summary>Color-space conversion function to import RGB samples</summary>
+        /// <param name="wpic">The WebPPicture structure</param>
+        /// <param name="bgr">Point to BGR data</param>
+        /// <param name="stride">stride of BGR data</param>
+        /// <returns>Returns 0 in case of memory error.</returns>
+        internal static int WebPPictureImportBGRX(ref WebPPicture wpic, IntPtr bgr, int stride)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPPictureImportBGRX_x86(ref wpic, bgr, stride);
+                case 8:
+                    return WebPPictureImportBGRX_x64(ref wpic, bgr, stride);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureImportBGRX")]
+        private static extern int WebPPictureImportBGRX_x86(ref WebPPicture wpic, IntPtr bgr, int stride);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureImportBGRX")]
+        private static extern int WebPPictureImportBGRX_x64(ref WebPPicture wpic, IntPtr bgr, int stride);
+
+        /// <summary>The writer type for output compress data</summary>
+        /// <param name="data">Data returned</param>
+        /// <param name="data_size">Size of data returned</param>
+        /// <param name="wpic">Picture structure</param>
+        /// <returns></returns>
+        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+        internal delegate int WebPMemoryWrite([In()] IntPtr data, UIntPtr data_size, ref WebPPicture wpic);
+        internal static WebPMemoryWrite OnCallback;
+
+        /// <summary>Compress to WebP format</summary>
+        /// <param name="config">The configuration structure for compression parameters</param>
+        /// <param name="picture">'picture' hold the source samples in both YUV(A) or ARGB input</param>
+        /// <returns>Returns 0 in case of error, 1 otherwise. In case of error, picture->error_code is updated accordingly.</returns>
+        internal static int WebPEncode(ref WebPConfig config, ref WebPPicture picture)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPEncode_x86(ref config, ref picture);
+                case 8:
+                    return WebPEncode_x64(ref config, ref picture);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncode")]
+        private static extern int WebPEncode_x86(ref WebPConfig config, ref WebPPicture picture);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncode")]
+        private static extern int WebPEncode_x64(ref WebPConfig config, ref WebPPicture picture);
+
+        /// <summary>Release the memory allocated by WebPPictureAlloc() or WebPPictureImport*()
+        /// Note that this function does _not_ free the memory used by the 'picture' object itself.
+        /// Besides memory (which is reclaimed) all other fields of 'picture' are preserved</summary>
+        /// <param name="picture">Picture structure</param>
+        internal static void WebPPictureFree(ref WebPPicture picture)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    WebPPictureFree_x86(ref picture);
+                    break;
+                case 8:
+                    WebPPictureFree_x64(ref picture);
+                    break;
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureFree")]
+        private static extern void WebPPictureFree_x86(ref WebPPicture wpic);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureFree")]
+        private static extern void WebPPictureFree_x64(ref WebPPicture wpic);
+
+        /// <summary>Validate the WebP image header and retrieve the image height and width. Pointers *width and *height can be passed NULL if deemed irrelevant</summary>
+        /// <param name="data">Pointer to WebP image data</param>
+        /// <param name="data_size">This is the size of the memory block pointed to by data containing the image data</param>
+        /// <param name="width">The range is limited currently from 1 to 16383</param>
+        /// <param name="height">The range is limited currently from 1 to 16383</param>
+        /// <returns>1 if success, otherwise error code returned in the case of (a) formatting error(s).</returns>
+        internal static int WebPGetInfo(IntPtr data, int data_size, out int width, out int height)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPGetInfo_x86(data, (UIntPtr)data_size, out width, out height);
+                case 8:
+                    return WebPGetInfo_x64(data, (UIntPtr)data_size, out width, out height);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPGetInfo")]
+        private static extern int WebPGetInfo_x86([InAttribute()] IntPtr data, UIntPtr data_size, out int width, out int height);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPGetInfo")]
+        private static extern int WebPGetInfo_x64([InAttribute()] IntPtr data, UIntPtr data_size, out int width, out int height);
+
+        /// <summary>Decode WEBP image pointed to by *data and returns BGR samples into a preallocated buffer</summary>
+        /// <param name="data">Pointer to WebP image data</param>
+        /// <param name="data_size">This is the size of the memory block pointed to by data containing the image data</param>
+        /// <param name="output_buffer">Pointer to decoded WebP image</param>
+        /// <param name="output_buffer_size">Size of allocated buffer</param>
+        /// <param name="output_stride">Specifies the distance between scan lines</param>
+        internal static void WebPDecodeBGRInto(IntPtr data, int data_size, IntPtr output_buffer, int output_buffer_size, int output_stride)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    if (WebPDecodeBGRInto_x86(data, (UIntPtr)data_size, output_buffer, output_buffer_size, output_stride) == null)
+                        throw new InvalidOperationException("Can not decode WebP");
+                    break;
+                case 8:
+                    if (WebPDecodeBGRInto_x64(data, (UIntPtr)data_size, output_buffer, output_buffer_size, output_stride) == null)
+                        throw new InvalidOperationException("Can not decode WebP");
+                    break;
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecodeBGRInto")]
+        private static extern IntPtr WebPDecodeBGRInto_x86([InAttribute()] IntPtr data, UIntPtr data_size, IntPtr output_buffer, int output_buffer_size, int output_stride);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecodeBGRInto")]
+        private static extern IntPtr WebPDecodeBGRInto_x64([InAttribute()] IntPtr data, UIntPtr data_size, IntPtr output_buffer, int output_buffer_size, int output_stride);
+
+        /// <summary>Decode WEBP image pointed to by *data and returns BGRA samples into a preallocated buffer</summary>
+        /// <param name="data">Pointer to WebP image data</param>
+        /// <param name="data_size">This is the size of the memory block pointed to by data containing the image data</param>
+        /// <param name="output_buffer">Pointer to decoded WebP image</param>
+        /// <param name="output_buffer_size">Size of allocated buffer</param>
+        /// <param name="output_stride">Specifies the distance between scan lines</param>
+        internal static void WebPDecodeBGRAInto(IntPtr data, int data_size, IntPtr output_buffer, int output_buffer_size, int output_stride)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    if (WebPDecodeBGRAInto_x86(data, (UIntPtr)data_size, output_buffer, output_buffer_size, output_stride) == null)
+                        throw new InvalidOperationException("Can not decode WebP"); 
+                    break;
+                case 8:
+                    if (WebPDecodeBGRAInto_x64(data, (UIntPtr)data_size, output_buffer, output_buffer_size, output_stride) == null)
+                        throw new InvalidOperationException("Can not decode WebP");
+                    break;
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecodeBGRAInto")]
+        private static extern IntPtr WebPDecodeBGRAInto_x86([InAttribute()] IntPtr data, UIntPtr data_size, IntPtr output_buffer, int output_buffer_size, int output_stride);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecodeBGRAInto")]
+        private static extern IntPtr WebPDecodeBGRAInto_x64([InAttribute()] IntPtr data, UIntPtr data_size, IntPtr output_buffer, int output_buffer_size, int output_stride);
+
+        /// <summary>Decode WEBP image pointed to by *data and returns ARGB samples into a preallocated buffer</summary>
+        /// <param name="data">Pointer to WebP image data</param>
+        /// <param name="data_size">This is the size of the memory block pointed to by data containing the image data</param>
+        /// <param name="output_buffer">Pointer to decoded WebP image</param>
+        /// <param name="output_buffer_size">Size of allocated buffer</param>
+        /// <param name="output_stride">Specifies the distance between scan lines</param>
+        internal static void WebPDecodeARGBInto(IntPtr data, int data_size, IntPtr output_buffer, int output_buffer_size, int output_stride)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    if (WebPDecodeARGBInto_x86(data, (UIntPtr)data_size, output_buffer, output_buffer_size, output_stride) == null)
+                        throw new InvalidOperationException("Can not decode WebP");
+                    break;
+                case 8:
+                    if (WebPDecodeARGBInto_x64(data, (UIntPtr)data_size, output_buffer, output_buffer_size, output_stride) == null)
+                        throw new InvalidOperationException("Can not decode WebP");
+                    break;
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecodeARGBInto")]
+        private static extern IntPtr WebPDecodeARGBInto_x86([InAttribute()] IntPtr data, UIntPtr data_size, IntPtr output_buffer, int output_buffer_size, int output_stride);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecodeARGBInto")]
+        private static extern IntPtr WebPDecodeARGBInto_x64([InAttribute()] IntPtr data, UIntPtr data_size, IntPtr output_buffer, int output_buffer_size, int output_stride);
+
+        /// <summary>Initialize the configuration as empty. This function must always be called first, unless WebPGetFeatures() is to be called</summary>
+        /// <param name="webPDecoderConfig">Configuration structure</param>
+        /// <returns>False in case of mismatched version.</returns>
+        internal static int WebPInitDecoderConfig(ref WebPDecoderConfig webPDecoderConfig)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPInitDecoderConfigInternal_x86(ref webPDecoderConfig, WEBP_DECODER_ABI_VERSION);
+                case 8:
+                    return WebPInitDecoderConfigInternal_x64(ref webPDecoderConfig, WEBP_DECODER_ABI_VERSION);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPInitDecoderConfigInternal")]
+        private static extern int WebPInitDecoderConfigInternal_x86(ref WebPDecoderConfig webPDecoderConfig, int WEBP_DECODER_ABI_VERSION);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPInitDecoderConfigInternal")]
+        private static extern int WebPInitDecoderConfigInternal_x64(ref WebPDecoderConfig webPDecoderConfig, int WEBP_DECODER_ABI_VERSION);
+
+        /// <summary>Decodes the full data at once, taking configuration into account</summary>
+        /// <param name="data">WebP raw data to decode</param>
+        /// <param name="data_size">Size of WebP data </param>
+        /// <param name="webPDecoderConfig">Configuration structure</param>
+        /// <returns>VP8_STATUS_OK if the decoding was successful</returns>
+        internal static VP8StatusCode WebPDecode(IntPtr data, int data_size, ref WebPDecoderConfig webPDecoderConfig)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPDecode_x86(data, (UIntPtr)data_size, ref webPDecoderConfig);
+                case 8:
+                    return WebPDecode_x64(data, (UIntPtr)data_size, ref webPDecoderConfig);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecode")]
+        private static extern VP8StatusCode WebPDecode_x86(IntPtr data, UIntPtr data_size, ref WebPDecoderConfig config);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecode")]
+        private static extern VP8StatusCode WebPDecode_x64(IntPtr data, UIntPtr data_size, ref WebPDecoderConfig config);
+
+        /// <summary>Free any memory associated with the buffer. Must always be called last. Doesn't free the 'buffer' structure itself</summary>
+        /// <param name="buffer">WebPDecBuffer</param>
+        internal static void WebPFreeDecBuffer(ref WebPDecBuffer buffer)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    WebPFreeDecBuffer_x86(ref buffer);
+                    break;
+                case 8:
+                    WebPFreeDecBuffer_x64(ref buffer);
+                    break;
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPFreeDecBuffer")]
+        private static extern void WebPFreeDecBuffer_x86(ref WebPDecBuffer buffer);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPFreeDecBuffer")]
+        private static extern void WebPFreeDecBuffer_x64(ref WebPDecBuffer buffer);
+
+        /// <summary>Lossy encoding images</summary>
+        /// <param name="bgr">Pointer to BGR image data</param>
+        /// <param name="width">The range is limited currently from 1 to 16383</param>
+        /// <param name="height">The range is limited currently from 1 to 16383</param>
+        /// <param name="stride">Specifies the distance between scanlines</param>
+        /// <param name="quality_factor">Ranges from 0 (lower quality) to 100 (highest quality). Controls the loss and quality during compression</param>
+        /// <param name="output">output_buffer with WebP image</param>
+        /// <returns>Size of WebP Image or 0 if an error occurred</returns>
+        internal static int WebPEncodeBGR(IntPtr bgr, int width, int height, int stride, float quality_factor, out IntPtr output)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPEncodeBGR_x86(bgr, width, height, stride, quality_factor, out output);
+                case 8:
+                    return WebPEncodeBGR_x64(bgr, width, height, stride, quality_factor, out output);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeBGR")]
+        private static extern int WebPEncodeBGR_x86([InAttribute()] IntPtr bgr, int width, int height, int stride, float quality_factor, out IntPtr output);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeBGR")]
+        private static extern int WebPEncodeBGR_x64([InAttribute()] IntPtr bgr, int width, int height, int stride, float quality_factor, out IntPtr output);
+
+        /// <summary>Lossy encoding images</summary>
+        /// <param name="bgr">Pointer to BGRA image data</param>
+        /// <param name="width">The range is limited currently from 1 to 16383</param>
+        /// <param name="height">The range is limited currently from 1 to 16383</param>
+        /// <param name="stride">Specifies the distance between scan lines</param>
+        /// <param name="quality_factor">Ranges from 0 (lower quality) to 100 (highest quality). Controls the loss and quality during compression</param>
+        /// <param name="output">output_buffer with WebP image</param>
+        /// <returns>Size of WebP Image or 0 if an error occurred</returns>
+        internal static int WebPEncodeBGRA(IntPtr bgra, int width, int height, int stride, float quality_factor, out IntPtr output)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPEncodeBGRA_x86(bgra, width, height, stride, quality_factor, out output);
+                case 8:
+                    return WebPEncodeBGRA_x64(bgra, width, height, stride, quality_factor, out output);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeBGRA")]
+        private static extern int WebPEncodeBGRA_x86([InAttribute()] IntPtr bgra, int width, int height, int stride, float quality_factor, out IntPtr output);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeBGRA")]
+        private static extern int WebPEncodeBGRA_x64([InAttribute()] IntPtr bgra, int width, int height, int stride, float quality_factor, out IntPtr output);
+
+        /// <summary>Lossless encoding images pointed to by *data in WebP format</summary>
+        /// <param name="bgr">Pointer to BGR image data</param>
+        /// <param name="width">The range is limited currently from 1 to 16383</param>
+        /// <param name="height">The range is limited currently from 1 to 16383</param>
+        /// <param name="stride">Specifies the distance between scan lines</param>
+        /// <param name="output">output_buffer with WebP image</param>
+        /// <returns>Size of WebP Image or 0 if an error occurred</returns>
+        internal static int WebPEncodeLosslessBGR(IntPtr bgr, int width, int height, int stride, out IntPtr output)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPEncodeLosslessBGR_x86(bgr, width, height, stride, out output);
+                case 8:
+                    return WebPEncodeLosslessBGR_x64(bgr, width, height, stride, out output);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeLosslessBGR")]
+        private static extern int WebPEncodeLosslessBGR_x86([InAttribute()] IntPtr bgr, int width, int height, int stride, out IntPtr output);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeLosslessBGR")]
+        private static extern int WebPEncodeLosslessBGR_x64([InAttribute()] IntPtr bgr, int width, int height, int stride, out IntPtr output);
+
+        /// <summary>Lossless encoding images pointed to by *data in WebP format</summary>
+        /// <param name="bgra">Pointer to BGRA image data</param>
+        /// <param name="width">The range is limited currently from 1 to 16383</param>
+        /// <param name="height">The range is limited currently from 1 to 16383</param>
+        /// <param name="stride">Specifies the distance between scan lines</param>
+        /// <param name="output">output_buffer with WebP image</param>
+        /// <returns>Size of WebP Image or 0 if an error occurred</returns>
+        internal static int WebPEncodeLosslessBGRA(IntPtr bgra, int width, int height, int stride, out IntPtr output)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPEncodeLosslessBGRA_x86(bgra, width, height, stride, out output);
+                case 8:
+                    return WebPEncodeLosslessBGRA_x64(bgra, width, height, stride, out output);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeLosslessBGRA")]
+        private static extern int WebPEncodeLosslessBGRA_x86([InAttribute()] IntPtr bgra, int width, int height, int stride, out IntPtr output);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeLosslessBGRA")]
+        private static extern int WebPEncodeLosslessBGRA_x64([InAttribute()] IntPtr bgra, int width, int height, int stride, out IntPtr output);
+
+        /// <summary>Releases memory returned by the WebPEncode</summary>
+        /// <param name="p">Pointer to memory</param>
+        internal static void WebPFree(IntPtr p)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    WebPFree_x86(p);
+                    break;
+                case 8:
+                    WebPFree_x64(p);
+                    break;
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPFree")]
+        private static extern void WebPFree_x86(IntPtr p);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPFree")]
+        private static extern void WebPFree_x64(IntPtr p);
+
+        /// <summary>Get the WebP version library</summary>
+        /// <returns>8bits for each of major/minor/revision packet in integer. E.g: v2.5.7 is 0x020507</returns>
+        internal static int WebPGetDecoderVersion()
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPGetDecoderVersion_x86();
+                case 8:
+                    return WebPGetDecoderVersion_x64();
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPGetDecoderVersion")]
+        private static extern int WebPGetDecoderVersion_x86();
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPGetDecoderVersion")]
+        private static extern int WebPGetDecoderVersion_x64();
+
+        /// <summary>Compute PSNR, SSIM or LSIM distortion metric between two pictures</summary>
+        /// <param name="srcPicture">Picture to measure</param>
+        /// <param name="refPicture">Reference picture</param>
+        /// <param name="metric_type">0 = PSNR, 1 = SSIM, 2 = LSIM</param>
+        /// <param name="pResult">dB in the Y/U/V/Alpha/All order</param>
+        /// <returns>False in case of error (the two pictures don't have same dimension, ...)</returns>
+        internal static int WebPPictureDistortion(ref WebPPicture srcPicture, ref WebPPicture refPicture, int metric_type, IntPtr pResult)
+        {
+            switch (IntPtr.Size)
+            {
+                case 4:
+                    return WebPPictureDistortion_x86(ref srcPicture, ref refPicture, metric_type, pResult);
+                case 8:
+                    return WebPPictureDistortion_x64(ref srcPicture, ref refPicture, metric_type, pResult);
+                default:
+                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
+            }
+        }
+        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureDistortion")]
+        private static extern int WebPPictureDistortion_x86(ref WebPPicture srcPicture, ref WebPPicture refPicture, int metric_type, IntPtr pResult);
+        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureDistortion")]
+        private static extern int WebPPictureDistortion_x64(ref WebPPicture srcPicture, ref WebPPicture refPicture, int metric_type, IntPtr pResult);
+    }
+    #endregion
+
+    #region | Predefined |
+    /// <summary>Enumerate some predefined settings for WebPConfig, depending on the type of source picture. These presets are used when calling WebPConfigPreset()</summary>
+    internal enum WebPPreset
+    {
+        /// <summary>Default preset</summary>
+        WEBP_PRESET_DEFAULT = 0,
+        /// <summary>Digital picture, like portrait, inner shot</summary>
+        WEBP_PRESET_PICTURE,
+        /// <summary>Outdoor photograph, with natural lighting</summary>
+        WEBP_PRESET_PHOTO,
+        /// <summary>Hand or line drawing, with high-contrast details</summary>
+        WEBP_PRESET_DRAWING,
+        /// <summary>Small-sized colorful images</summary>
+        WEBP_PRESET_ICON,
+        /// <summary>Text-like</summary>
+        WEBP_PRESET_TEXT
+    };
+
+    /// <summary>Encoding error conditions</summary>
+    internal enum WebPEncodingError
+    {
+        /// <summary>No error</summary>
+        VP8_ENC_OK = 0,
+        /// <summary>Memory error allocating objects</summary>
+        VP8_ENC_ERROR_OUT_OF_MEMORY,
+        /// <summary>Memory error while flushing bits</summary>
+        VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY,
+        /// <summary>A pointer parameter is NULL</summary>
+        VP8_ENC_ERROR_NULL_PARAMETER,
+        /// <summary>Configuration is invalid</summary>
+        VP8_ENC_ERROR_INVALID_CONFIGURATION,
+        /// <summary>Picture has invalid width/height</summary>
+        VP8_ENC_ERROR_BAD_DIMENSION,
+        /// <summary>Partition is bigger than 512k</summary>
+        VP8_ENC_ERROR_PARTITION0_OVERFLOW,
+        /// <summary>Partition is bigger than 16M</summary>
+        VP8_ENC_ERROR_PARTITION_OVERFLOW,
+        /// <summary>Error while flushing bytes</summary>
+        VP8_ENC_ERROR_BAD_WRITE,
+        /// <summary>File is bigger than 4G</summary>
+        VP8_ENC_ERROR_FILE_TOO_BIG,
+        /// <summary>Abort request by user</summary>
+        VP8_ENC_ERROR_USER_ABORT,
+        /// <summary>List terminator. Always last</summary>
+        VP8_ENC_ERROR_LAST,
+    }
+
+    /// <summary>Enumeration of the status codes</summary>
+    internal enum VP8StatusCode
+    {
+        /// <summary>No error</summary>
+        VP8_STATUS_OK = 0,
+        /// <summary>Memory error allocating objects</summary>
+        VP8_STATUS_OUT_OF_MEMORY,
+        /// <summary>Configuration is invalid</summary>
+        VP8_STATUS_INVALID_PARAM,
+        VP8_STATUS_BITSTREAM_ERROR,
+        /// <summary>Configuration is invalid</summary>
+        VP8_STATUS_UNSUPPORTED_FEATURE,
+        VP8_STATUS_SUSPENDED,
+        /// <summary>Abort request by user</summary>
+        VP8_STATUS_USER_ABORT,
+        VP8_STATUS_NOT_ENOUGH_DATA,
+    }
+
+    /// <summary>Image characteristics hint for the underlying encoder</summary>
+    internal enum WebPImageHint
+    {
+        /// <summary>Default preset</summary>
+        WEBP_HINT_DEFAULT = 0,
+        /// <summary>Digital picture, like portrait, inner shot</summary>
+        WEBP_HINT_PICTURE,
+        /// <summary>Outdoor photograph, with natural lighting</summary>
+        WEBP_HINT_PHOTO,
+        /// <summary>Discrete tone image (graph, map-tile etc)</summary>
+        WEBP_HINT_GRAPH,
+        /// <summary>List terminator. Always last</summary>
+        WEBP_HINT_LAST
+    };
+
+    /// <summary>Describes the byte-ordering of packed samples in memory</summary>
+    internal enum WEBP_CSP_MODE
+    {
+        /// <summary>Byte-order: R,G,B,R,G,B,..</summary>
+        MODE_RGB = 0,
+        /// <summary>Byte-order: R,G,B,A,R,G,B,A,..</summary>
+        MODE_RGBA = 1,
+        /// <summary>Byte-order: B,G,R,B,G,R,..</summary>
+        MODE_BGR = 2,
+        /// <summary>Byte-order: B,G,R,A,B,G,R,A,..</summary>
+        MODE_BGRA = 3,
+        /// <summary>Byte-order: A,R,G,B,A,R,G,B,..</summary>
+        MODE_ARGB = 4,
+        /// <summary>Byte-order: RGB-565: [a4 a3 a2 a1 a0 r5 r4 r3], [r2 r1 r0 g4 g3 g2 g1 g0], ...
+        /// WEBP_SWAP_16BITS_CSP is defined, 
+        /// Byte-order: RGB-565: [a4 a3 a2 a1 a0 b5 b4 b3], [b2 b1 b0 g4 g3 g2 g1 g0], ..</summary>
+        MODE_RGBA_4444 = 5,
+        /// <summary>Byte-order: RGB-565: [r4 r3 r2 r1 r0 g5 g4 g3], [g2 g1 g0 b4 b3 b2 b1 b0], ...
+        /// WEBP_SWAP_16BITS_CSP is defined, 
+        /// Byte-order: [b3 b2 b1 b0 a3 a2 a1 a0], [r3 r2 r1 r0 g3 g2 g1 g0], ..</summary>
+        MODE_RGB_565 = 6,
+        /// <summary>RGB-premultiplied transparent modes (alpha value is preserved)</summary>
+        MODE_rgbA = 7,
+        /// <summary>RGB-premultiplied transparent modes (alpha value is preserved)</summary>
+        MODE_bgrA = 8,
+        /// <summary>RGB-premultiplied transparent modes (alpha value is preserved)</summary>
+        MODE_Argb = 9,
+        /// <summary>RGB-premultiplied transparent modes (alpha value is preserved)</summary>
+        MODE_rgbA_4444 = 10,
+        /// <summary>YUV 4:2:0</summary>
+        MODE_YUV = 11,
+        /// <summary>YUV 4:2:0</summary>
+        MODE_YUVA = 12,
+        /// <summary>MODE_LAST -> 13</summary>
+        MODE_LAST = 13,
+    }
+
+    /// <summary>
+    /// Decoding states. State normally flows as:
+    /// WEBP_HEADER->VP8_HEADER->VP8_PARTS0->VP8_DATA->DONE for a lossy image, and
+    /// WEBP_HEADER->VP8L_HEADER->VP8L_DATA->DONE for a lossless image.
+    /// If there is any error the decoder goes into state ERROR.
+    /// </summary>
+    internal enum DecState
+    {
+        STATE_WEBP_HEADER,  // All the data before that of the VP8/VP8L chunk.
+        STATE_VP8_HEADER,   // The VP8 Frame header (within the VP8 chunk).
+        STATE_VP8_PARTS0,
+        STATE_VP8_DATA,
+        STATE_VP8L_HEADER,
+        STATE_VP8L_DATA,
+        STATE_DONE,
+        STATE_ERROR
+    };
+    #endregion
+
+    #region | libwebp structs |
+    /// <summary>Features gathered from the bit stream</summary>
+    [StructLayoutAttribute(LayoutKind.Sequential)]
+    internal struct WebPBitstreamFeatures
+    {
+        /// <summary>Width in pixels, as read from the bit stream</summary>
+        public int Width;
+        /// <summary>Height in pixels, as read from the bit stream</summary>
+        public int Height;
+        /// <summary>True if the bit stream contains an alpha channel</summary>
+        public int Has_alpha;
+        /// <summary>True if the bit stream is an animation</summary>
+        public int Has_animation;
+        /// <summary>0 = undefined (/mixed), 1 = lossy, 2 = lossless</summary>
+        public int Format;
+        /// <summary>Padding for later use</summary>
+        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.U4)]
+        private readonly uint[] pad;
+    };
+
+    /// <summary>Compression parameters</summary>
+    [StructLayoutAttribute(LayoutKind.Sequential)]
+    internal struct WebPConfig
+    {
+        /// <summary>Lossless encoding (0=lossy(default), 1=lossless)</summary>
+        public int lossless;
+        /// <summary>Between 0 (smallest file) and 100 (biggest)</summary>
+        public float quality;
+        /// <summary>Quality/speed trade-off (0=fast, 6=slower-better)</summary>
+        public int method;
+        /// <summary>Hint for image type (lossless only for now)</summary>
+        public WebPImageHint image_hint;
+        /// <summary>If non-zero, set the desired target size in bytes. Takes precedence over the 'compression' parameter</summary>
+        public int target_size;
+        /// <summary>If non-zero, specifies the minimal distortion to try to achieve. Takes precedence over target_size</summary>
+        public float target_PSNR;
+        /// <summary>Maximum number of segments to use, in [1..4]</summary>
+        public int segments;
+        /// <summary>Spatial Noise Shaping. 0=off, 100=maximum</summary>
+        public int sns_strength;
+        /// <summary>Range: [0 = off .. 100 = strongest]</summary>
+        public int filter_strength;
+        /// <summary>Range: [0 = off .. 7 = least sharp]</summary>
+        public int filter_sharpness;
+        /// <summary>Filtering type: 0 = simple, 1 = strong (only used if filter_strength > 0 or auto-filter > 0)</summary>
+        public int filter_type;
+        /// <summary>Auto adjust filter's strength [0 = off, 1 = on]</summary>
+        public int autofilter;
+        /// <summary>Algorithm for encoding the alpha plane (0 = none, 1 = compressed with WebP lossless). Default is 1</summary>
+        public int alpha_compression;
+        /// <summary>Predictive filtering method for alpha plane. 0: none, 1: fast, 2: best. Default if 1</summary>
+        public int alpha_filtering;
+        /// <summary>Between 0 (smallest size) and 100 (lossless). Default is 100</summary>
+        public int alpha_quality;
+        /// <summary>Number of entropy-analysis passes (in [1..10])</summary>
+        public int pass;
+        /// <summary>If true, export the compressed picture back. In-loop filtering is not applied</summary>
+        public int show_compressed;
+        /// <summary>Preprocessing filter (0=none, 1=segment-smooth, 2=pseudo-random dithering)</summary>
+        public int preprocessing;
+        /// <summary>Log2(number of token partitions) in [0..3] Default is set to 0 for easier progressive decoding</summary>
+        public int partitions;
+        /// <summary>Quality degradation allowed to fit the 512k limit on prediction modes coding (0: no degradation, 100: maximum possible degradation)</summary>
+        public int partition_limit;
+        /// <summary>If true, compression parameters will be remapped to better match the expected output size from JPEG compression. Generally, the output size will be similar but the degradation will be lower</summary>
+        public int emulate_jpeg_size;
+        /// <summary>If non-zero, try and use multi-threaded encoding</summary>
+        public int thread_level;
+        /// <summary>If set, reduce memory usage (but increase CPU use)</summary>
+        public int low_memory;
+        /// <summary>Near lossless encoding [0 = max loss .. 100 = off (default)]</summary>
+        public int near_lossless;
+        /// <summary>If non-zero, preserve the exact RGB values under transparent area. Otherwise, discard this invisible RGB information for better compression. The default value is 0</summary>
+        public int exact;
+        /// <summary>Reserved for future lossless feature</summary>
+        public int delta_palettization;
+        /// <summary>If needed, use sharp (and slow) RGB->YUV conversion</summary>
+        public int use_sharp_yuv;
+        /// <summary>Padding for later use</summary>
+        private readonly int pad1;
+        private readonly int pad2;
+    };
+
+    /// <summary>Main exchange structure (input samples, output bytes, statistics)</summary>
+    [StructLayoutAttribute(LayoutKind.Sequential)]
+    internal struct WebPPicture
+    {
+        /// <summary>Main flag for encoder selecting between ARGB or YUV input. Recommended to use ARGB input (*argb, argb_stride) for lossless, and YUV input (*y, *u, *v, etc.) for lossy</summary>
+        public int use_argb;
+        /// <summary>Color-space: should be YUV420 for now (=Y'CbCr). Value = 0</summary>
+        public UInt32 colorspace;
+        /// <summary>Width of picture (less or equal to WEBP_MAX_DIMENSION)</summary>
+        public int width;
+        /// <summary>Height of picture (less or equal to WEBP_MAX_DIMENSION)</summary>
+        public int height;
+        /// <summary>Pointer to luma plane</summary>
+        public IntPtr y;
+        /// <summary>Pointer to chroma U plane</summary>
+        public IntPtr u;
+        /// <summary>Pointer to chroma V plane</summary>
+        public IntPtr v;
+        /// <summary>Luma stride</summary>
+        public int y_stride;
+        /// <summary>Chroma stride</summary>
+        public int uv_stride;
+        /// <summary>Pointer to the alpha plane</summary>
+        public IntPtr a;
+        /// <summary>stride of the alpha plane</summary>
+        public int a_stride;
+        /// <summary>Padding for later use</summary>
+        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.U4)]
+        private readonly uint[] pad1;
+        /// <summary>Pointer to ARGB (32 bit) plane</summary>
+        public IntPtr argb;
+        /// <summary>This is stride in pixels units, not bytes</summary>
+        public int argb_stride;
+        /// <summary>Padding for later use</summary>
+        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.U4)]
+        private readonly uint[] pad2;
+        /// <summary>Byte-emission hook, to store compressed bytes as they are ready</summary>
+        public IntPtr writer;
+        /// <summary>Can be used by the writer</summary>
+        public IntPtr custom_ptr;
+        // map for extra information (only for lossy compression mode)
+        /// <summary>1: intra type, 2: segment, 3: quant, 4: intra-16 prediction mode, 5: chroma prediction mode, 6: bit cost, 7: distortion</summary>
+        public int extra_info_type;
+        /// <summary>If not NULL, points to an array of size ((width + 15) / 16) * ((height + 15) / 16) that will be filled with a macroblock map, depending on extra_info_type</summary>
+        public IntPtr extra_info;
+        /// <summary>Pointer to side statistics (updated only if not NULL)</summary>
+        public IntPtr stats;
+        /// <summary>Error code for the latest error encountered during encoding</summary>
+        public UInt32 error_code;
+        /// <summary>If not NULL, report progress during encoding</summary>
+        public IntPtr progress_hook;
+        /// <summary>This field is free to be set to any value and used during callbacks (like progress-report e.g.)</summary>
+        public IntPtr user_data;
+        /// <summary>Padding for later use</summary>
+        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 13, ArraySubType = UnmanagedType.U4)]
+        private readonly uint[] pad3;
+        /// <summary>Row chunk of memory for YUVA planes</summary>
+        private readonly IntPtr memory_;
+        /// <summary>Row chunk of memory for ARGB planes</summary>
+        private readonly IntPtr memory_argb_;
+        /// <summary>Padding for later use</summary>
+        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.U4)]
+        private readonly uint[] pad4;
+    };
+
+    /// <summary>Structure for storing auxiliary statistics (mostly for lossy encoding)</summary>
+    [StructLayoutAttribute(LayoutKind.Sequential)]
+    internal struct WebPAuxStats
+    {
+        /// <summary>Final size</summary>
+        public int coded_size;
+        /// <summary>Peak-signal-to-noise ratio for Y</summary>
+        public float PSNRY;
+        /// <summary>Peak-signal-to-noise ratio for U</summary>
+        public float PSNRU;
+        /// <summary>Peak-signal-to-noise ratio for V</summary>
+        public float PSNRV;
+        /// <summary>Peak-signal-to-noise ratio for All</summary>
+        public float PSNRALL;
+        /// <summary>Peak-signal-to-noise ratio for Alpha</summary>
+        public float PSNRAlpha;
+        /// <summary>Number of intra4</summary>
+        public int block_count_intra4;
+        /// <summary>Number of intra16</summary>
+        public int block_count_intra16;
+        /// <summary>Number of skipped macro-blocks</summary>
+        public int block_count_skipped;
+        /// <summary>Approximate number of bytes spent for header</summary>
+        public int header_bytes;
+        /// <summary>Approximate number of bytes spent for  mode-partition #0</summary>
+        public int mode_partition_0;
+        /// <summary>Approximate number of bytes spent for DC coefficients for segment 0</summary>
+        public int residual_bytes_DC_segments0;
+        /// <summary>Approximate number of bytes spent for AC coefficients for segment 0</summary>
+        public int residual_bytes_AC_segments0;
+        /// <summary>Approximate number of bytes spent for UV coefficients for segment 0</summary>
+        public int residual_bytes_uv_segments0;
+        /// <summary>Approximate number of bytes spent for DC coefficients for segment 1</summary>
+        public int residual_bytes_DC_segments1;
+        /// <summary>Approximate number of bytes spent for AC coefficients for segment 1</summary>
+        public int residual_bytes_AC_segments1;
+        /// <summary>Approximate number of bytes spent for UV coefficients for segment 1</summary>
+        public int residual_bytes_uv_segments1;
+        /// <summary>Approximate number of bytes spent for DC coefficients for segment 2</summary>
+        public int residual_bytes_DC_segments2;
+        /// <summary>Approximate number of bytes spent for AC coefficients for segment 2</summary>
+        public int residual_bytes_AC_segments2;
+        /// <summary>Approximate number of bytes spent for UV coefficients for segment 2</summary>
+        public int residual_bytes_uv_segments2;
+        /// <summary>Approximate number of bytes spent for DC coefficients for segment 3</summary>
+        public int residual_bytes_DC_segments3;
+        /// <summary>Approximate number of bytes spent for AC coefficients for segment 3</summary>
+        public int residual_bytes_AC_segments3;
+        /// <summary>Approximate number of bytes spent for UV coefficients for segment 3</summary>
+        public int residual_bytes_uv_segments3;
+        /// <summary>Number of macro-blocks in segments 0</summary>
+        public int segment_size_segments0;
+        /// <summary>Number of macro-blocks in segments 1</summary>
+        public int segment_size_segments1;
+        /// <summary>Number of macro-blocks in segments 2</summary>
+        public int segment_size_segments2;
+        /// <summary>Number of macro-blocks in segments 3</summary>
+        public int segment_size_segments3;
+        /// <summary>Quantizer values for segment 0</summary>
+        public int segment_quant_segments0;
+        /// <summary>Quantizer values for segment 1</summary>
+        public int segment_quant_segments1;
+        /// <summary>Quantizer values for segment 2</summary>
+        public int segment_quant_segments2;
+        /// <summary>Quantizer values for segment 3</summary>
+        public int segment_quant_segments3;
+        /// <summary>Filtering strength for segment 0 [0..63]</summary>
+        public int segment_level_segments0;
+        /// <summary>Filtering strength for segment 1 [0..63]</summary>
+        public int segment_level_segments1;
+        /// <summary>Filtering strength for segment 2 [0..63]</summary>
+        public int segment_level_segments2;
+        /// <summary>Filtering strength for segment 3 [0..63]</summary>
+        public int segment_level_segments3;
+        /// <summary>Size of the transparency data</summary>
+        public int alpha_data_size;
+        /// <summary>Size of the enhancement layer data</summary>
+        public int layer_data_size;
+
+        // lossless encoder statistics
+        /// <summary>bit0:predictor bit1:cross-color transform bit2:subtract-green bit3:color indexing</summary>
+        public Int32 lossless_features;
+        /// <summary>Number of precision bits of histogram</summary>
+        public int histogram_bits;
+        /// <summary>Precision bits for transform</summary>
+        public int transform_bits;
+        /// <summary>Number of bits for color cache lookup</summary>
+        public int cache_bits;
+        /// <summary>Number of color in palette, if used</summary>
+        public int palette_size;
+        /// <summary>Final lossless size</summary>
+        public int lossless_size;
+        /// <summary>Lossless header (transform, Huffman, etc) size</summary>
+        public int lossless_hdr_size;
+        /// <summary>Lossless image data size</summary>
+        public int lossless_data_size;
+        /// <summary>Padding for later use</summary>
+        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.U4)]
+        private readonly uint[] pad;
+    };
+
+    [StructLayoutAttribute(LayoutKind.Sequential)]
+    internal struct WebPDecoderConfig
+    {
+        /// <summary>Immutable bit stream features (optional)</summary>
+        public WebPBitstreamFeatures input;
+        /// <summary>Output buffer (can point to external memory)</summary>
+        public WebPDecBuffer output;
+        /// <summary>Decoding options</summary>
+        public WebPDecoderOptions options;
+    }
+
+    /// <summary>Output buffer</summary>
+    [StructLayoutAttribute(LayoutKind.Sequential)]
+    internal struct WebPDecBuffer
+    {
+        /// <summary>Color space</summary>
+        public WEBP_CSP_MODE colorspace;
+        /// <summary>Width of image</summary>
+        public int width;
+        /// <summary>Height of image</summary>
+        public int height;
+        /// <summary>If non-zero, 'internal_memory' pointer is not used. If value is '2' or more, the external memory is considered 'slow' and multiple read/write will be avoided</summary>
+        public int is_external_memory;
+        /// <summary>Output buffer parameters</summary>
+        public RGBA_YUVA_Buffer u;
+        /// <summary>Padding for later use</summary>
+        private readonly UInt32 pad1;
+        /// <summary>Padding for later use</summary>
+        private readonly UInt32 pad2;
+        /// <summary>Padding for later use</summary>
+        private readonly UInt32 pad3;
+        /// <summary>Padding for later use</summary>
+        private readonly UInt32 pad4;
+        /// <summary>Internally allocated memory (only when is_external_memory is 0). Should not be used externally, but accessed via WebPRGBABuffer</summary>
+        public IntPtr private_memory;
+    }
+
+    /// <summary>Union of buffer parameters</summary>
+    [StructLayoutAttribute(LayoutKind.Explicit)]
+    internal struct RGBA_YUVA_Buffer
+    {
+        [FieldOffsetAttribute(0)]
+        public WebPRGBABuffer RGBA;
+
+        [FieldOffsetAttribute(0)]
+        public WebPYUVABuffer YUVA;
+    }
+
+    [StructLayoutAttribute(LayoutKind.Sequential)]
+    internal struct WebPYUVABuffer
+    {
+        /// <summary>Pointer to luma samples</summary>
+        public IntPtr y;
+        /// <summary>Pointer to chroma U samples</summary>
+        public IntPtr u;
+        /// <summary>Pointer to chroma V samples</summary>
+        public IntPtr v;
+        /// <summary>Pointer to alpha samples</summary>
+        public IntPtr a;
+        /// <summary>Luma stride</summary>
+        public int y_stride;
+        /// <summary>Chroma U stride</summary>
+        public int u_stride;
+        /// <summary>Chroma V stride</summary>
+        public int v_stride;
+        /// <summary>Alpha stride</summary>
+        public int a_stride;
+        /// <summary>Luma plane size</summary>
+        public UIntPtr y_size;
+        /// <summary>Chroma plane U size</summary>
+        public UIntPtr u_size;
+        /// <summary>Chroma plane V size</summary>
+        public UIntPtr v_size;
+        /// <summary>Alpha plane size</summary>
+        public UIntPtr a_size;
+    }
+
+    /// <summary>Generic structure for describing the output sample buffer</summary>
+    [StructLayoutAttribute(LayoutKind.Sequential)]
+    internal struct WebPRGBABuffer
+    {
+        /// <summary>Pointer to RGBA samples</summary>
+        public IntPtr rgba;
+        /// <summary>Stride in bytes from one scanline to the next</summary>
+        public int stride;
+        /// <summary>Total size of the RGBA buffer</summary>
+        public UIntPtr size;
+    }
+
+    /// <summary>Decoding options</summary>
+    [StructLayout(LayoutKind.Sequential)]
+    public struct WebPDecoderOptions
+    {
+        /// <summary>If true, skip the in-loop filtering</summary>
+        public int bypass_filtering;
+        /// <summary>If true, use faster point-wise up-sampler</summary>
+        public int no_fancy_upsampling;
+        /// <summary>If true, cropping is applied _first_</summary>
+        public int use_cropping;
+        /// <summary>Left position for cropping. Will be snapped to even values</summary>
+        public int crop_left;
+        /// <summary>Top position for cropping. Will be snapped to even values</summary>
+        public int crop_top;
+        /// <summary>Width of the cropping area</summary>
+        public int crop_width;
+        /// <summary>Height of the cropping area</summary>
+        public int crop_height;
+        /// <summary>If true, scaling is applied _afterward_</summary>
+        public int use_scaling;
+        /// <summary>Final width</summary>
+        public int scaled_width;
+        /// <summary>Final height</summary>
+        public int scaled_height;
+        /// <summary>If true, use multi-threaded decoding</summary>
+        public int use_threads;
+        /// <summary>Dithering strength (0=Off, 100=full)</summary>
+        public int dithering_strength;
+        /// <summary>Flip output vertically</summary>
+        public int flip;
+        /// <summary>Alpha dithering strength in [0..100]</summary>
+        public int alpha_dithering_strength;
+        /// <summary>Padding for later use</summary>
+        private readonly UInt32 pad1;
+        /// <summary>Padding for later use</summary>
+        private readonly UInt32 pad2;
+        /// <summary>Padding for later use</summary>
+        private readonly UInt32 pad3;
+        /// <summary>Padding for later use</summary>
+        private readonly UInt32 pad4;
+        /// <summary>Padding for later use</summary>
+        private readonly UInt32 pad5;
+    };
+    #endregion
+}
\ No newline at end of file
diff --git a/Emuera/app.config b/Emuera/app.config
deleted file mode 100644
index 3e0e37c..0000000
diff --git a/net7.patch b/net7.patch
new file mode 100644
index 0000000..0a0ba4d
--- /dev/null
+++ b/net7.patch
@@ -0,0 +1,1983 @@
+diff --git a/Emuera/_Library/WebPWrapper.cs b/Emuera/_Library/WebPWrapper.cs
+new file mode 100644
+index 0000000..f21e98f
+--- /dev/null
++++ b/Emuera/_Library/WebPWrapper.cs
+@@ -0,0 +1,1976 @@
++﻿/////////////////////////////////////////////////////////////////////////////////////////////////////////////
++/// Wrapper for WebP format in C#. (MIT) Jose M. Piñeiro
++///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
++/// Decode Functions:
++/// Bitmap Load(string pathFileName) - Load a WebP file in bitmap.
++/// Bitmap Decode(byte[] rawWebP) - Decode WebP data (rawWebP) to bitmap.
++/// Bitmap Decode(byte[] rawWebP, WebPDecoderOptions options) - Decode WebP data (rawWebP) to bitmap using 'options'.
++/// Bitmap GetThumbnailFast(byte[] rawWebP, int width, int height) - Get a thumbnail from WebP data (rawWebP) with dimensions 'width x height'. Fast mode.
++/// Bitmap GetThumbnailQuality(byte[] rawWebP, int width, int height) - Fast get a thumbnail from WebP data (rawWebP) with dimensions 'width x height'. Quality mode.
++/// 
++/// Encode Functions:
++/// Save(Bitmap bmp, string pathFileName, int quality) - Save bitmap with quality lost to WebP file. Opcionally select 'quality'.
++/// byte[] EncodeLossy(Bitmap bmp, int quality) - Encode bitmap with quality lost to WebP byte array. Opcionally select 'quality'.
++/// byte[] EncodeLossy(Bitmap bmp, int quality, int speed, bool info) - Encode bitmap with quality lost to WebP byte array. Select 'quality', 'speed' and optionally select 'info'.
++/// byte[] EncodeLossless(Bitmap bmp) - Encode bitmap without quality lost to WebP byte array. 
++/// byte[] EncodeLossless(Bitmap bmp, int speed, bool info = false) - Encode bitmap without quality lost to WebP byte array. Select 'speed'. 
++/// byte[] EncodeNearLossless(Bitmap bmp, int quality, int speed = 9, bool info = false) - Encode bitmap with a near lossless method to WebP byte array. Select 'quality', 'speed' and optionally select 'info'.
++/// 
++/// Another functions:
++/// string GetVersion() - Get the library version
++/// GetInfo(byte[] rawWebP, out int width, out int height, out bool has_alpha, out bool has_animation, out string format) - Get information of WEBP data
++/// float[] PictureDistortion(Bitmap source, Bitmap reference, int metric_type) - Get PSNR, SSIM or LSIM distortion metric between two pictures
++/////////////////////////////////////////////////////////////////////////////////////////////////////////////
++using System;
++using System.Drawing;
++using System.Drawing.Imaging;
++using System.IO;
++using System.Runtime.InteropServices;
++using System.Security;
++using System.Windows.Forms;
++
++namespace WebPWrapper
++{
++    public sealed class WebP : IDisposable
++    {
++        private const int WEBP_MAX_DIMENSION = 16383;
++        #region | Public Decode Functions |
++        /// <summary>Read a WebP file</summary>
++        /// <param name="pathFileName">WebP file to load</param>
++        /// <returns>Bitmap with the WebP image</returns>
++        public Bitmap Load(string pathFileName)
++        {
++            try
++            {
++                byte[] rawWebP = File.ReadAllBytes(pathFileName);
++
++                return Decode(rawWebP);
++            }
++            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.Load"); }
++        }
++
++        /// <summary>Decode a WebP image</summary>
++        /// <param name="rawWebP">The data to uncompress</param>
++        /// <returns>Bitmap with the WebP image</returns>
++        public Bitmap Decode(byte[] rawWebP)
++        {
++            Bitmap bmp = null;
++            BitmapData bmpData = null;
++            GCHandle pinnedWebP = GCHandle.Alloc(rawWebP, GCHandleType.Pinned);
++
++            try
++            {
++                //Get image width and height
++                GetInfo(rawWebP, out int imgWidth, out int imgHeight, out bool hasAlpha, out bool hasAnimation, out string format);
++
++                //Create a BitmapData and Lock all pixels to be written
++                if (hasAlpha)
++                    bmp = new Bitmap(imgWidth, imgHeight, PixelFormat.Format32bppArgb);
++                else
++                    bmp = new Bitmap(imgWidth, imgHeight, PixelFormat.Format24bppRgb);
++                bmpData = bmp.LockBits(new Rectangle(0, 0, imgWidth, imgHeight), ImageLockMode.WriteOnly, bmp.PixelFormat);
++
++                //Uncompress the image
++                int outputSize = bmpData.Stride * imgHeight;
++                IntPtr ptrData = pinnedWebP.AddrOfPinnedObject();
++                if (bmp.PixelFormat == PixelFormat.Format24bppRgb)
++                     UnsafeNativeMethods.WebPDecodeBGRInto(ptrData, rawWebP.Length, bmpData.Scan0, outputSize, bmpData.Stride);
++                else
++                     UnsafeNativeMethods.WebPDecodeBGRAInto(ptrData, rawWebP.Length, bmpData.Scan0, outputSize, bmpData.Stride);
++
++                return bmp;
++            }
++            catch (Exception) { throw; }
++            finally
++            {
++                //Unlock the pixels
++                if (bmpData != null)
++                    bmp.UnlockBits(bmpData);
++
++                //Free memory
++                if (pinnedWebP.IsAllocated)
++                    pinnedWebP.Free();
++            }
++        }
++
++        /// <summary>Decode a WebP image</summary>
++        /// <param name="rawWebP">the data to uncompress</param>
++        /// <param name="options">Options for advanced decode</param>
++        /// <returns>Bitmap with the WebP image</returns>
++        public Bitmap Decode(byte[] rawWebP, WebPDecoderOptions options, PixelFormat pixelFormat = PixelFormat.DontCare)
++        {
++            GCHandle pinnedWebP = GCHandle.Alloc(rawWebP, GCHandleType.Pinned);
++            Bitmap bmp = null;
++            BitmapData bmpData = null;
++            VP8StatusCode result;
++            try
++            {
++                WebPDecoderConfig config = new WebPDecoderConfig();
++                if (UnsafeNativeMethods.WebPInitDecoderConfig(ref config) == 0)
++                {
++                    throw new Exception("WebPInitDecoderConfig failed. Wrong version?");
++                }
++                // Read the .webp input file information
++                IntPtr ptrRawWebP = pinnedWebP.AddrOfPinnedObject();
++                int height;
++                int width;
++                if (options.use_scaling == 0)
++                {
++                    result = UnsafeNativeMethods.WebPGetFeatures(ptrRawWebP, rawWebP.Length, ref config.input);
++                    if (result != VP8StatusCode.VP8_STATUS_OK)
++                        throw new Exception("Failed WebPGetFeatures with error " + result);
++
++                    //Test cropping values
++                    if (options.use_cropping == 1)
++                    {
++                        if (options.crop_left + options.crop_width > config.input.Width || options.crop_top + options.crop_height > config.input.Height)
++                            throw new Exception("Crop options exceeded WebP image dimensions");
++                        width = options.crop_width;
++                        height = options.crop_height;
++                    }
++                }
++                else
++                {
++                    width = options.scaled_width;
++                    height = options.scaled_height;
++                }
++
++                config.options.bypass_filtering = options.bypass_filtering;
++                config.options.no_fancy_upsampling = options.no_fancy_upsampling;
++                config.options.use_cropping = options.use_cropping;
++                config.options.crop_left = options.crop_left;
++                config.options.crop_top = options.crop_top;
++                config.options.crop_width = options.crop_width;
++                config.options.crop_height = options.crop_height;
++                config.options.use_scaling = options.use_scaling;
++                config.options.scaled_width = options.scaled_width;
++                config.options.scaled_height = options.scaled_height;
++                config.options.use_threads = options.use_threads;
++                config.options.dithering_strength = options.dithering_strength;
++                config.options.flip = options.flip;
++                config.options.alpha_dithering_strength = options.alpha_dithering_strength;
++
++                //Create a BitmapData and Lock all pixels to be written
++                if (config.input.Has_alpha == 1)
++                {
++                    config.output.colorspace = WEBP_CSP_MODE.MODE_bgrA;
++                    bmp = new Bitmap(config.input.Width, config.input.Height, PixelFormat.Format32bppArgb);
++                }
++                else
++                {
++                    config.output.colorspace = WEBP_CSP_MODE.MODE_BGR;
++                    bmp = new Bitmap(config.input.Width, config.input.Height, PixelFormat.Format24bppRgb);
++                }
++                bmpData = bmp.LockBits(new Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.WriteOnly, bmp.PixelFormat);
++
++                // Specify the output format
++                config.output.u.RGBA.rgba = bmpData.Scan0;
++                config.output.u.RGBA.stride = bmpData.Stride;
++                config.output.u.RGBA.size = (UIntPtr)(bmp.Height * bmpData.Stride);
++                config.output.height = bmp.Height;
++                config.output.width = bmp.Width;
++                config.output.is_external_memory = 1;
++
++                // Decode
++                result = UnsafeNativeMethods.WebPDecode(ptrRawWebP, rawWebP.Length, ref config);
++                if (result != VP8StatusCode.VP8_STATUS_OK)
++                {
++                    throw new Exception("Failed WebPDecode with error " + result);
++                }
++                UnsafeNativeMethods.WebPFreeDecBuffer(ref config.output);
++
++                return bmp;
++            }
++            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.Decode"); }
++            finally
++            {
++                //Unlock the pixels
++                if (bmpData != null)
++                    bmp.UnlockBits(bmpData);
++
++                //Free memory
++                if (pinnedWebP.IsAllocated)
++                    pinnedWebP.Free();
++            }
++        }
++
++        /// <summary>Get Thumbnail from webP in mode faster/low quality</summary>
++        /// <param name="rawWebP">The data to uncompress</param>
++        /// <param name="width">Wanted width of thumbnail</param>
++        /// <param name="height">Wanted height of thumbnail</param>
++        /// <returns>Bitmap with the WebP thumbnail in 24bpp</returns>
++        public Bitmap GetThumbnailFast(byte[] rawWebP, int width, int height)
++        {
++            GCHandle pinnedWebP = GCHandle.Alloc(rawWebP, GCHandleType.Pinned);
++            Bitmap bmp = null;
++            BitmapData bmpData = null;
++
++            try
++            {
++                WebPDecoderConfig config = new WebPDecoderConfig();
++                if (UnsafeNativeMethods.WebPInitDecoderConfig(ref config) == 0)
++                    throw new Exception("WebPInitDecoderConfig failed. Wrong version?");
++
++                // Set up decode options
++                config.options.bypass_filtering = 1;
++                config.options.no_fancy_upsampling = 1;
++                config.options.use_threads = 1;
++                config.options.use_scaling = 1;
++                config.options.scaled_width = width;
++                config.options.scaled_height = height;
++
++                // Create a BitmapData and Lock all pixels to be written
++                bmp = new Bitmap(width, height, PixelFormat.Format24bppRgb);
++                bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.WriteOnly, bmp.PixelFormat);
++
++                // Specify the output format
++                config.output.colorspace = WEBP_CSP_MODE.MODE_BGR;
++                config.output.u.RGBA.rgba = bmpData.Scan0;
++                config.output.u.RGBA.stride = bmpData.Stride;
++                config.output.u.RGBA.size = (UIntPtr)(height * bmpData.Stride);
++                config.output.height = height;
++                config.output.width = width;
++                config.output.is_external_memory = 1;
++
++                // Decode
++                IntPtr ptrRawWebP = pinnedWebP.AddrOfPinnedObject();
++                VP8StatusCode result = UnsafeNativeMethods.WebPDecode(ptrRawWebP, rawWebP.Length, ref config);
++                if (result != VP8StatusCode.VP8_STATUS_OK)
++                    throw new Exception("Failed WebPDecode with error " + result);
++
++                UnsafeNativeMethods.WebPFreeDecBuffer(ref config.output);
++
++                return bmp;
++            }
++            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.Thumbnail"); }
++            finally
++            {
++                //Unlock the pixels
++                if (bmpData != null)
++                    bmp.UnlockBits(bmpData);
++
++                //Free memory
++                if (pinnedWebP.IsAllocated)
++                    pinnedWebP.Free();
++            }
++        }
++
++        /// <summary>Thumbnail from webP in mode slow/high quality</summary>
++        /// <param name="rawWebP">The data to uncompress</param>
++        /// <param name="width">Wanted width of thumbnail</param>
++        /// <param name="height">Wanted height of thumbnail</param>
++        /// <returns>Bitmap with the WebP thumbnail</returns>
++        public Bitmap GetThumbnailQuality(byte[] rawWebP, int width, int height)
++        {
++            GCHandle pinnedWebP = GCHandle.Alloc(rawWebP, GCHandleType.Pinned);
++            Bitmap bmp = null;
++            BitmapData bmpData = null;
++
++            try
++            {
++                WebPDecoderConfig config = new WebPDecoderConfig();
++                if (UnsafeNativeMethods.WebPInitDecoderConfig(ref config) == 0)
++                    throw new Exception("WebPInitDecoderConfig failed. Wrong version?");
++
++                IntPtr ptrRawWebP = pinnedWebP.AddrOfPinnedObject();
++                VP8StatusCode result = UnsafeNativeMethods.WebPGetFeatures(ptrRawWebP, rawWebP.Length, ref config.input);
++                if (result != VP8StatusCode.VP8_STATUS_OK)
++                    throw new Exception("Failed WebPGetFeatures with error " + result);
++
++                // Set up decode options
++                config.options.bypass_filtering = 0;
++                config.options.no_fancy_upsampling = 0;
++                config.options.use_threads = 1;
++                config.options.use_scaling = 1;
++                config.options.scaled_width = width;
++                config.options.scaled_height = height;
++
++                //Create a BitmapData and Lock all pixels to be written
++                if (config.input.Has_alpha == 1)
++                {
++                    config.output.colorspace = WEBP_CSP_MODE.MODE_bgrA;
++                    bmp = new Bitmap(width, height, PixelFormat.Format32bppArgb);
++                }
++                else
++                {
++                    config.output.colorspace = WEBP_CSP_MODE.MODE_BGR;
++                    bmp = new Bitmap(width, height, PixelFormat.Format24bppRgb);
++                }
++                bmpData = bmp.LockBits(new Rectangle(0, 0, width, height), ImageLockMode.WriteOnly, bmp.PixelFormat);
++
++                // Specify the output format
++                config.output.u.RGBA.rgba = bmpData.Scan0;
++                config.output.u.RGBA.stride = bmpData.Stride;
++                config.output.u.RGBA.size = (UIntPtr)(height * bmpData.Stride);
++                config.output.height = height;
++                config.output.width = width;
++                config.output.is_external_memory = 1;
++
++                // Decode
++                result = UnsafeNativeMethods.WebPDecode(ptrRawWebP, rawWebP.Length, ref config);
++                if (result != VP8StatusCode.VP8_STATUS_OK)
++                    throw new Exception("Failed WebPDecode with error " + result);
++
++                UnsafeNativeMethods.WebPFreeDecBuffer(ref config.output);
++
++                return bmp;
++            }
++            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.Thumbnail"); }
++            finally
++            {
++                //Unlock the pixels
++                if (bmpData != null)
++                    bmp.UnlockBits(bmpData);
++
++                //Free memory
++                if (pinnedWebP.IsAllocated)
++                    pinnedWebP.Free();
++            }
++        }
++        #endregion
++
++        #region | Public Encode Functions |
++        /// <summary>Save bitmap to file in WebP format</summary>
++        /// <param name="bmp">Bitmap with the WebP image</param>
++        /// <param name="pathFileName">The file to write</param>
++        /// <param name="quality">Between 0 (lower quality, lowest file size) and 100 (highest quality, higher file size)</param>
++        public void Save(Bitmap bmp, string pathFileName, int quality = 75)
++        {
++            byte[] rawWebP;
++
++            try
++            {
++                //Encode in webP format
++                rawWebP = EncodeLossy(bmp, quality);
++
++                //Write webP file
++                File.WriteAllBytes(pathFileName, rawWebP);
++            }
++            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.Save"); }
++        }
++
++        /// <summary>Lossy encoding bitmap to WebP (Simple encoding API)</summary>
++        /// <param name="bmp">Bitmap with the image</param>
++        /// <param name="quality">Between 0 (lower quality, lowest file size) and 100 (highest quality, higher file size)</param>
++        /// <returns>Compressed data</returns>
++        public byte[] EncodeLossy(Bitmap bmp, int quality = 75)
++        {
++            //test bmp
++            if (bmp.Width == 0 || bmp.Height == 0)
++                throw new ArgumentException("Bitmap contains no data.", "bmp");
++            if (bmp.Width > WEBP_MAX_DIMENSION || bmp.Height > WEBP_MAX_DIMENSION)
++                throw new NotSupportedException("Bitmap's dimension is too large. Max is " + WEBP_MAX_DIMENSION + "x" + WEBP_MAX_DIMENSION + " pixels.");
++            if (bmp.PixelFormat != PixelFormat.Format24bppRgb && bmp.PixelFormat != PixelFormat.Format32bppArgb)
++                throw new NotSupportedException("Only support Format24bppRgb and Format32bppArgb pixelFormat.");
++
++            BitmapData bmpData = null;
++            IntPtr unmanagedData = IntPtr.Zero;
++
++            try
++            {
++                int size;
++                
++                //Get bmp data
++                bmpData = bmp.LockBits(new Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.ReadOnly, bmp.PixelFormat);
++
++                //Compress the bmp data
++                if (bmp.PixelFormat == PixelFormat.Format24bppRgb)
++                    size = UnsafeNativeMethods.WebPEncodeBGR(bmpData.Scan0, bmp.Width, bmp.Height, bmpData.Stride, quality, out unmanagedData);
++                else
++                    size = UnsafeNativeMethods.WebPEncodeBGRA(bmpData.Scan0, bmp.Width, bmp.Height, bmpData.Stride, quality, out unmanagedData);
++                if (size == 0)
++                    throw new Exception("Can´t encode WebP");
++
++                //Copy image compress data to output array
++                byte[] rawWebP = new byte[size];
++                Marshal.Copy(unmanagedData, rawWebP, 0, size);
++
++                return rawWebP;
++            }
++            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.EncodeLossly"); }
++            finally
++            {
++                //Unlock the pixels
++                if (bmpData != null)
++                    bmp.UnlockBits(bmpData);
++
++                //Free memory
++                if (unmanagedData != IntPtr.Zero)
++                    UnsafeNativeMethods.WebPFree(unmanagedData);
++            }
++        }
++
++        /// <summary>Lossy encoding bitmap to WebP (Advanced encoding API)</summary>
++        /// <param name="bmp">Bitmap with the image</param>
++        /// <param name="quality">Between 0 (lower quality, lowest file size) and 100 (highest quality, higher file size)</param>
++        /// <param name="speed">Between 0 (fastest, lowest compression) and 9 (slower, best compression)</param>
++        /// <returns>Compressed data</returns>
++        public byte[] EncodeLossy(Bitmap bmp, int quality, int speed, bool info = false)
++        {
++            //Initialize configuration structure
++            WebPConfig config = new WebPConfig();
++
++            //Set compression parameters
++            if (UnsafeNativeMethods.WebPConfigInit(ref config, WebPPreset.WEBP_PRESET_DEFAULT, 75) == 0)
++                throw new Exception("Can´t configure preset");
++
++            // Add additional tuning:
++            config.method = speed;
++            if (config.method > 6)
++                config.method = 6;
++            config.quality = quality;
++            config.autofilter = 1;
++            config.pass = speed + 1;
++            config.segments = 4;
++            config.partitions = 3;
++            config.thread_level = 1;
++            config.alpha_quality = quality;
++            config.alpha_filtering = 2;
++            config.use_sharp_yuv = 1;
++
++            if (UnsafeNativeMethods.WebPGetDecoderVersion() > 1082)     //Old version does not support preprocessing 4
++            {
++                config.preprocessing = 4;
++                config.use_sharp_yuv = 1;
++            }
++            else
++                config.preprocessing = 3;
++
++            return AdvancedEncode(bmp, config, info);
++        }
++
++        /// <summary>Lossless encoding bitmap to WebP (Simple encoding API)</summary>
++        /// <param name="bmp">Bitmap with the image</param>
++        /// <returns>Compressed data</returns>
++        public byte[] EncodeLossless(Bitmap bmp)
++        {
++            //test bmp
++            if (bmp.Width == 0 || bmp.Height == 0)
++                throw new ArgumentException("Bitmap contains no data.", "bmp");
++            if (bmp.Width > WEBP_MAX_DIMENSION || bmp.Height > WEBP_MAX_DIMENSION)
++                throw new NotSupportedException("Bitmap's dimension is too large. Max is " + WEBP_MAX_DIMENSION + "x" + WEBP_MAX_DIMENSION + " pixels.");
++            if (bmp.PixelFormat != PixelFormat.Format24bppRgb && bmp.PixelFormat != PixelFormat.Format32bppArgb)
++                throw new NotSupportedException("Only support Format24bppRgb and Format32bppArgb pixelFormat.");
++
++            BitmapData bmpData = null;
++            IntPtr unmanagedData = IntPtr.Zero;
++            try
++            {
++                //Get bmp data
++                bmpData = bmp.LockBits(new Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.ReadOnly, bmp.PixelFormat);
++
++                //Compress the bmp data
++                int size;
++                if (bmp.PixelFormat == PixelFormat.Format24bppRgb)
++                    size = UnsafeNativeMethods.WebPEncodeLosslessBGR(bmpData.Scan0, bmp.Width, bmp.Height, bmpData.Stride, out unmanagedData);
++                else
++                    size = UnsafeNativeMethods.WebPEncodeLosslessBGRA(bmpData.Scan0, bmp.Width, bmp.Height, bmpData.Stride, out unmanagedData);
++
++                //Copy image compress data to output array
++                byte[] rawWebP = new byte[size];
++                Marshal.Copy(unmanagedData, rawWebP, 0, size);
++
++                return rawWebP;
++            }
++            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.EncodeLossless (Simple)"); }
++            finally
++            {
++                //Unlock the pixels
++                if (bmpData != null)
++                    bmp.UnlockBits(bmpData);
++
++                //Free memory
++                if (unmanagedData != IntPtr.Zero)
++                    UnsafeNativeMethods.WebPFree(unmanagedData);
++            }
++        }
++
++        /// <summary>Lossless encoding image in bitmap (Advanced encoding API)</summary>
++        /// <param name="bmp">Bitmap with the image</param>
++        /// <param name="speed">Between 0 (fastest, lowest compression) and 9 (slower, best compression)</param>
++        /// <returns>Compressed data</returns>
++        public byte[] EncodeLossless(Bitmap bmp, int speed)
++        {
++            //Initialize configuration structure
++            WebPConfig config = new WebPConfig();
++
++            //Set compression parameters
++            if (UnsafeNativeMethods.WebPConfigInit(ref config, WebPPreset.WEBP_PRESET_DEFAULT, (speed + 1) * 10) == 0)
++                throw new Exception("Can´t config preset");
++
++            //Old version of DLL does not support info and WebPConfigLosslessPreset
++            if (UnsafeNativeMethods.WebPGetDecoderVersion() > 1082)
++            {
++                if (UnsafeNativeMethods.WebPConfigLosslessPreset(ref config, speed) == 0)
++                    throw new Exception("Can´t configure lossless preset");
++            }
++            else
++            {
++                config.lossless = 1;
++                config.method = speed;
++                if (config.method > 6)
++                    config.method = 6;
++                config.quality = (speed + 1) * 10;
++            }
++            config.pass = speed + 1;
++            config.thread_level = 1;
++            config.alpha_filtering = 2;
++            config.use_sharp_yuv = 1;
++            config.exact = 0;
++
++            return AdvancedEncode(bmp, config, false);
++        }
++
++        /// <summary>Near lossless encoding image in bitmap</summary>
++        /// <param name="bmp">Bitmap with the image</param>
++        /// <param name="quality">Between 0 (lower quality, lowest file size) and 100 (highest quality, higher file size)</param>
++        /// <param name="speed">Between 0 (fastest, lowest compression) and 9 (slower, best compression)</param>
++        /// <returns>Compress data</returns>
++        public byte[] EncodeNearLossless(Bitmap bmp, int quality, int speed = 9)
++        {
++            //test DLL version
++            if (UnsafeNativeMethods.WebPGetDecoderVersion() <= 1082)
++                throw new Exception("This DLL version not support EncodeNearLossless");
++
++            //Inicialize config struct
++            WebPConfig config = new WebPConfig();
++
++            //Set compression parameters
++            if (UnsafeNativeMethods.WebPConfigInit(ref config, WebPPreset.WEBP_PRESET_DEFAULT, (speed + 1) * 10) == 0)
++                throw new Exception("Can´t configure preset");
++            if (UnsafeNativeMethods.WebPConfigLosslessPreset(ref config, speed) == 0)
++                throw new Exception("Can´t configure lossless preset");
++            config.pass = speed + 1;
++            config.near_lossless = quality;
++            config.thread_level = 1;
++            config.alpha_filtering = 2;
++            config.use_sharp_yuv = 1;
++            config.exact = 0;
++
++            return AdvancedEncode(bmp, config, false);
++        }
++        #endregion
++
++        #region | Another Public Functions |
++        /// <summary>Get the libwebp version</summary>
++        /// <returns>Version of library</returns>
++        public string GetVersion()
++        {
++            try
++            {
++                uint v = (uint)UnsafeNativeMethods.WebPGetDecoderVersion();
++                var revision = v % 256;
++                var minor = (v >> 8) % 256;
++                var major = (v >> 16) % 256;
++                return major + "." + minor + "." + revision;
++            }
++            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.GetVersion"); }
++        }
++
++        /// <summary>Get info of WEBP data</summary>
++        /// <param name="rawWebP">The data of WebP</param>
++        /// <param name="width">width of image</param>
++        /// <param name="height">height of image</param>
++        /// <param name="has_alpha">Image has alpha channel</param>
++        /// <param name="has_animation">Image is a animation</param>
++        /// <param name="format">Format of image: 0 = undefined (/mixed), 1 = lossy, 2 = lossless</param>
++        public void GetInfo(byte[] rawWebP, out int width, out int height, out bool has_alpha, out bool has_animation, out string format)
++        {
++            VP8StatusCode result;
++            GCHandle pinnedWebP = GCHandle.Alloc(rawWebP, GCHandleType.Pinned);
++
++            try
++            {
++                IntPtr ptrRawWebP = pinnedWebP.AddrOfPinnedObject();
++
++                WebPBitstreamFeatures features = new WebPBitstreamFeatures();
++                result = UnsafeNativeMethods.WebPGetFeatures(ptrRawWebP, rawWebP.Length, ref features);
++
++                if (result != 0)
++                    throw new Exception(result.ToString());
++
++                width = features.Width;
++                height = features.Height;
++                if (features.Has_alpha == 1) has_alpha = true; else has_alpha = false;
++                if (features.Has_animation == 1) has_animation = true; else has_animation = false;
++                switch (features.Format)
++                {
++                    case 1:
++                        format = "lossy";
++                        break;
++                    case 2:
++                        format = "lossless";
++                        break;
++                    default:
++                        format = "undefined";
++                        break;
++                }
++            }
++            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.GetInfo"); }
++            finally
++            {
++                //Free memory
++                if (pinnedWebP.IsAllocated)
++                    pinnedWebP.Free();
++            }
++        }
++
++        /// <summary>Compute PSNR, SSIM or LSIM distortion metric between two pictures. Warning: this function is rather CPU-intensive</summary>
++        /// <param name="source">Picture to measure</param>
++        /// <param name="reference">Reference picture</param>
++        /// <param name="metric_type">0 = PSNR, 1 = SSIM, 2 = LSIM</param>
++        /// <returns>dB in the Y/U/V/Alpha/All order</returns>
++        public float[] GetPictureDistortion(Bitmap source, Bitmap reference, int metric_type)
++        {
++            WebPPicture wpicSource = new WebPPicture();
++            WebPPicture wpicReference = new WebPPicture();
++            BitmapData sourceBmpData = null;
++            BitmapData referenceBmpData = null;
++            float[] result = new float[5];
++            GCHandle pinnedResult = GCHandle.Alloc(result, GCHandleType.Pinned);
++
++            try
++            {
++                if (source == null)
++                    throw new Exception("Source picture is void");
++                if (reference == null)
++                    throw new Exception("Reference picture is void");
++                if (metric_type > 2)
++                    throw new Exception("Bad metric_type. Use 0 = PSNR, 1 = SSIM, 2 = LSIM");
++                if (source.Width != reference.Width || source.Height != reference.Height)
++                    throw new Exception("Source and Reference pictures have different dimensions");
++
++                // Setup the source picture data, allocating the bitmap, width and height
++                sourceBmpData = source.LockBits(new Rectangle(0, 0, source.Width, source.Height), ImageLockMode.ReadOnly, source.PixelFormat);
++                wpicSource = new WebPPicture();
++                if (UnsafeNativeMethods.WebPPictureInitInternal(ref wpicSource) != 1)
++                    throw new Exception("Can´t initialize WebPPictureInit");
++                wpicSource.width = (int)source.Width;
++                wpicSource.height = (int)source.Height;
++
++                //Put the source bitmap componets in wpic
++                if (sourceBmpData.PixelFormat == PixelFormat.Format32bppArgb)
++                {
++                    wpicSource.use_argb = 1;
++                    if (UnsafeNativeMethods.WebPPictureImportBGRA(ref wpicSource, sourceBmpData.Scan0, sourceBmpData.Stride) != 1)
++                        throw new Exception("Can´t allocate memory in WebPPictureImportBGR");
++                }
++                else
++                {
++                    wpicSource.use_argb = 0;
++                    if (UnsafeNativeMethods.WebPPictureImportBGR(ref wpicSource, sourceBmpData.Scan0, sourceBmpData.Stride) != 1)
++                        throw new Exception("Can´t allocate memory in WebPPictureImportBGR");
++                }
++
++                // Setup the reference picture data, allocating the bitmap, width and height
++                referenceBmpData = reference.LockBits(new Rectangle(0, 0, reference.Width, reference.Height), ImageLockMode.ReadOnly, reference.PixelFormat);
++                wpicReference = new WebPPicture();
++                if (UnsafeNativeMethods.WebPPictureInitInternal(ref wpicReference) != 1)
++                    throw new Exception("Can´t initialize WebPPictureInit");
++                wpicReference.width = (int)reference.Width;
++                wpicReference.height = (int)reference.Height;
++                wpicReference.use_argb = 1;
++
++                //Put the source bitmap contents in WebPPicture instance
++                if (sourceBmpData.PixelFormat == PixelFormat.Format32bppArgb)
++                {
++                    wpicSource.use_argb = 1;
++                    if (UnsafeNativeMethods.WebPPictureImportBGRA(ref wpicReference, referenceBmpData.Scan0, referenceBmpData.Stride) != 1)
++                        throw new Exception("Can´t allocate memory in WebPPictureImportBGR");
++                }
++                else
++                {
++                    wpicSource.use_argb = 0;
++                    if (UnsafeNativeMethods.WebPPictureImportBGR(ref wpicReference, referenceBmpData.Scan0, referenceBmpData.Stride) != 1)
++                        throw new Exception("Can´t allocate memory in WebPPictureImportBGR");
++                }
++
++                //Measure
++                IntPtr ptrResult = pinnedResult.AddrOfPinnedObject();
++                if (UnsafeNativeMethods.WebPPictureDistortion(ref wpicSource, ref wpicReference, metric_type, ptrResult) != 1)
++                    throw new Exception("Can´t measure.");
++                return result;
++            }
++            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.GetPictureDistortion"); }
++            finally
++            {
++                //Unlock the pixels
++                if (sourceBmpData != null)
++                    source.UnlockBits(sourceBmpData);
++                if (referenceBmpData != null)
++                    reference.UnlockBits(referenceBmpData);
++
++                //Free memory
++                if (wpicSource.argb != IntPtr.Zero)
++                    UnsafeNativeMethods.WebPPictureFree(ref wpicSource);
++                if (wpicReference.argb != IntPtr.Zero)
++                    UnsafeNativeMethods.WebPPictureFree(ref wpicReference);
++                //Free memory
++                if (pinnedResult.IsAllocated)
++                    pinnedResult.Free();
++            }
++        }
++        #endregion
++
++        #region | Private Methods |
++        /// <summary>Encoding image  using Advanced encoding API</summary>
++        /// <param name="bmp">Bitmap with the image</param>
++        /// <param name="config">Configuration for encode</param>
++        /// <param name="info">True if need encode info.</param>
++        /// <returns>Compressed data</returns>
++        private byte[] AdvancedEncode(Bitmap bmp, WebPConfig config, bool info)
++        {
++            byte[] rawWebP = null;
++            byte[] dataWebp = null;
++            WebPPicture wpic = new WebPPicture();
++            BitmapData bmpData = null;
++            WebPAuxStats stats = new WebPAuxStats();
++            IntPtr ptrStats = IntPtr.Zero;
++            GCHandle pinnedArrayHandle = new GCHandle();
++            int dataWebpSize;
++            try
++            {
++                //Validate the configuration
++                if (UnsafeNativeMethods.WebPValidateConfig(ref config) != 1)
++                    throw new Exception("Bad configuration parameters");
++
++                //test bmp
++                if (bmp.Width == 0 || bmp.Height == 0)
++                    throw new ArgumentException("Bitmap contains no data.", "bmp");
++                if (bmp.Width > WEBP_MAX_DIMENSION || bmp.Height > WEBP_MAX_DIMENSION)
++                    throw new NotSupportedException("Bitmap's dimension is too large. Max is " + WEBP_MAX_DIMENSION + "x" + WEBP_MAX_DIMENSION + " pixels.");
++                if (bmp.PixelFormat != PixelFormat.Format24bppRgb && bmp.PixelFormat != PixelFormat.Format32bppArgb)
++                    throw new NotSupportedException("Only support Format24bppRgb and Format32bppArgb pixelFormat.");
++
++                // Setup the input data, allocating a the bitmap, width and height
++                bmpData = bmp.LockBits(new Rectangle(0, 0, bmp.Width, bmp.Height), ImageLockMode.ReadOnly, bmp.PixelFormat);
++                if (UnsafeNativeMethods.WebPPictureInitInternal(ref wpic) != 1)
++                    throw new Exception("Can´t initialize WebPPictureInit");
++                wpic.width = (int)bmp.Width;
++                wpic.height = (int)bmp.Height;
++                wpic.use_argb = 1;
++
++                if (bmp.PixelFormat == PixelFormat.Format32bppArgb)
++                {
++                    //Put the bitmap componets in wpic
++                    int result = UnsafeNativeMethods.WebPPictureImportBGRA(ref wpic, bmpData.Scan0, bmpData.Stride);
++                    if (result != 1)
++                        throw new Exception("Can´t allocate memory in WebPPictureImportBGRA");
++                    wpic.colorspace = (uint)WEBP_CSP_MODE.MODE_bgrA;
++                    dataWebpSize = bmp.Width * bmp.Height * 32;
++                    dataWebp = new byte[bmp.Width * bmp.Height * 32];                //Memory for WebP output
++                }
++                else
++                {
++                    //Put the bitmap contents in WebPPicture instance
++                    int result = UnsafeNativeMethods.WebPPictureImportBGR(ref wpic, bmpData.Scan0, bmpData.Stride);
++                    if (result != 1)
++                        throw new Exception("Can´t allocate memory in WebPPictureImportBGR");
++                    dataWebpSize = bmp.Width * bmp.Height * 24;
++
++                }
++
++                //Set up statistics of compression
++                if (info)
++                {
++                    stats = new WebPAuxStats();
++                    ptrStats = Marshal.AllocHGlobal(Marshal.SizeOf(stats));
++                    Marshal.StructureToPtr(stats, ptrStats, false);
++                    wpic.stats = ptrStats;
++                }
++
++                //Memory for WebP output
++                if (dataWebpSize > 2147483591)
++                    dataWebpSize = 2147483591;
++                dataWebp = new byte[bmp.Width * bmp.Height * 32];
++                pinnedArrayHandle = GCHandle.Alloc(dataWebp, GCHandleType.Pinned);
++                IntPtr initPtr = pinnedArrayHandle.AddrOfPinnedObject();
++                wpic.custom_ptr = initPtr;
++
++                //Set up a byte-writing method (write-to-memory, in this case)
++                UnsafeNativeMethods.OnCallback = new UnsafeNativeMethods.WebPMemoryWrite(MyWriter);
++                wpic.writer = Marshal.GetFunctionPointerForDelegate(UnsafeNativeMethods.OnCallback);
++
++                //compress the input samples
++                if (UnsafeNativeMethods.WebPEncode(ref config, ref wpic) != 1)
++                    throw new Exception("Encoding error: " + ((WebPEncodingError)wpic.error_code).ToString());
++
++                //Remove OnCallback
++                UnsafeNativeMethods.OnCallback = null;
++
++                //Unlock the pixels
++                bmp.UnlockBits(bmpData);
++                bmpData = null;
++
++                //Copy webpData to rawWebP
++                int size = (int)((long)wpic.custom_ptr - (long)initPtr);
++                rawWebP = new byte[size];
++                Array.Copy(dataWebp, rawWebP, size);
++
++                //Remove compression data
++                pinnedArrayHandle.Free();
++                dataWebp = null;
++
++                //Show statistics
++                if (info)
++                {
++                    stats = (WebPAuxStats)Marshal.PtrToStructure(ptrStats, typeof(WebPAuxStats));
++                    MessageBox.Show("Dimension: " + wpic.width + " x " + wpic.height + " pixels\n" +
++                                    "Output:    " + stats.coded_size + " bytes\n" +
++                                    "PSNR Y:    " + stats.PSNRY + " db\n" +
++                                    "PSNR u:    " + stats.PSNRU + " db\n" +
++                                    "PSNR v:    " + stats.PSNRV + " db\n" +
++                                    "PSNR ALL:  " + stats.PSNRALL + " db\n" +
++                                    "Block intra4:  " + stats.block_count_intra4 + "\n" +
++                                    "Block intra16: " + stats.block_count_intra16 + "\n" +
++                                    "Block skipped: " + stats.block_count_skipped + "\n" +
++                                    "Header size:    " + stats.header_bytes + " bytes\n" +
++                                    "Mode-partition: " + stats.mode_partition_0 + " bytes\n" +
++                                    "Macro-blocks 0: " + stats.segment_size_segments0 + " residuals bytes\n" +
++                                    "Macro-blocks 1: " + stats.segment_size_segments1 + " residuals bytes\n" +
++                                    "Macro-blocks 2: " + stats.segment_size_segments2 + " residuals bytes\n" +
++                                    "Macro-blocks 3: " + stats.segment_size_segments3 + " residuals bytes\n" +
++                                    "Quantizer    0: " + stats.segment_quant_segments0 + " residuals bytes\n" +
++                                    "Quantizer    1: " + stats.segment_quant_segments1 + " residuals bytes\n" +
++                                    "Quantizer    2: " + stats.segment_quant_segments2 + " residuals bytes\n" +
++                                    "Quantizer    3: " + stats.segment_quant_segments3 + " residuals bytes\n" +
++                                    "Filter level 0: " + stats.segment_level_segments0 + " residuals bytes\n" +
++                                    "Filter level 1: " + stats.segment_level_segments1 + " residuals bytes\n" +
++                                    "Filter level 2: " + stats.segment_level_segments2 + " residuals bytes\n" +
++                                    "Filter level 3: " + stats.segment_level_segments3 + " residuals bytes\n", "Compression statistics");
++                }
++
++                return rawWebP;
++            }
++            catch (Exception ex) { throw new Exception(ex.Message + "\r\nIn WebP.AdvancedEncode"); }
++            finally
++            {
++                //Free temporal compress memory
++                if (pinnedArrayHandle.IsAllocated)
++                {
++                    pinnedArrayHandle.Free();
++                }
++
++                //Free statistics memory
++                if (ptrStats != IntPtr.Zero)
++                {
++                    Marshal.FreeHGlobal(ptrStats);
++                }
++
++                //Unlock the pixels
++                if (bmpData != null)
++                {
++                    bmp.UnlockBits(bmpData);
++                }
++
++                //Free memory
++                if (wpic.argb != IntPtr.Zero)
++                {
++                    UnsafeNativeMethods.WebPPictureFree(ref wpic);
++                }
++            }
++        }
++
++        private int MyWriter([InAttribute()] IntPtr data, UIntPtr data_size, ref WebPPicture picture)
++        {
++            UnsafeNativeMethods.CopyMemory(picture.custom_ptr, data, (uint)data_size);
++            //picture.custom_ptr = IntPtr.Add(picture.custom_ptr, (int)data_size);   //Only in .NET > 4.0
++            picture.custom_ptr = new IntPtr(picture.custom_ptr.ToInt64() + (int)data_size);
++            return 1;
++        }
++
++        private delegate int MyWriterDelegate([InAttribute()] IntPtr data, UIntPtr data_size, ref WebPPicture picture);
++        #endregion
++
++        #region | Destruction |
++        /// <summary>Free memory</summary>
++        public void Dispose()
++        {
++            GC.SuppressFinalize(this);
++        }
++        #endregion
++    }
++
++    #region | Import libwebp functions |
++    [SuppressUnmanagedCodeSecurityAttribute]
++    internal sealed partial class UnsafeNativeMethods
++    {
++
++        [DllImport("kernel32.dll", EntryPoint = "CopyMemory", SetLastError = false)]
++        internal static extern void CopyMemory(IntPtr dest, IntPtr src, uint count);
++
++        private static readonly int WEBP_DECODER_ABI_VERSION = 0x0208;
++
++        /// <summary>This function will initialize the configuration according to a predefined set of parameters (referred to by 'preset') and a given quality factor</summary>
++        /// <param name="config">The WebPConfig structure</param>
++        /// <param name="preset">Type of image</param>
++        /// <param name="quality">Quality of compression</param>
++        /// <returns>0 if error</returns>
++        internal static int WebPConfigInit(ref WebPConfig config, WebPPreset preset, float quality)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPConfigInitInternal_x86(ref config, preset, quality, WEBP_DECODER_ABI_VERSION);
++                case 8:
++                    return WebPConfigInitInternal_x64(ref config, preset, quality, WEBP_DECODER_ABI_VERSION);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPConfigInitInternal")]
++        private static extern int WebPConfigInitInternal_x86(ref WebPConfig config, WebPPreset preset, float quality, int WEBP_DECODER_ABI_VERSION);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPConfigInitInternal")]
++        private static extern int WebPConfigInitInternal_x64(ref WebPConfig config, WebPPreset preset, float quality, int WEBP_DECODER_ABI_VERSION);
++
++        /// <summary>Get info of WepP image</summary>
++        /// <param name="rawWebP">Bytes[] of WebP image</param>
++        /// <param name="data_size">Size of rawWebP</param>
++        /// <param name="features">Features of WebP image</param>
++        /// <returns>VP8StatusCode</returns>
++        internal static VP8StatusCode WebPGetFeatures(IntPtr rawWebP, int data_size, ref WebPBitstreamFeatures features)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPGetFeaturesInternal_x86(rawWebP, (UIntPtr)data_size, ref features, WEBP_DECODER_ABI_VERSION);
++                case 8:
++                    return WebPGetFeaturesInternal_x64(rawWebP, (UIntPtr)data_size, ref features, WEBP_DECODER_ABI_VERSION);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPGetFeaturesInternal")]
++        private static extern VP8StatusCode WebPGetFeaturesInternal_x86([InAttribute()] IntPtr rawWebP, UIntPtr data_size, ref WebPBitstreamFeatures features, int WEBP_DECODER_ABI_VERSION);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPGetFeaturesInternal")]
++        private static extern VP8StatusCode WebPGetFeaturesInternal_x64([InAttribute()] IntPtr rawWebP, UIntPtr data_size, ref WebPBitstreamFeatures features, int WEBP_DECODER_ABI_VERSION);
++
++        /// <summary>Activate the lossless compression mode with the desired efficiency</summary>
++        /// <param name="config">The WebPConfig struct</param>
++        /// <param name="level">between 0 (fastest, lowest compression) and 9 (slower, best compression)</param>
++        /// <returns>0 in case of parameter error</returns>
++        internal static int WebPConfigLosslessPreset(ref WebPConfig config, int level)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPConfigLosslessPreset_x86(ref config, level);
++                case 8:
++                    return WebPConfigLosslessPreset_x64(ref config, level);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPConfigLosslessPreset")]
++        private static extern int WebPConfigLosslessPreset_x86(ref WebPConfig config, int level);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPConfigLosslessPreset")]
++        private static extern int WebPConfigLosslessPreset_x64(ref WebPConfig config, int level);
++
++        /// <summary>Check that configuration is non-NULL and all configuration parameters are within their valid ranges</summary>
++        /// <param name="config">The WebPConfig structure</param>
++        /// <returns>1 if configuration is OK</returns>
++        internal static int WebPValidateConfig(ref WebPConfig config)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPValidateConfig_x86(ref config);
++                case 8:
++                    return WebPValidateConfig_x64(ref config);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPValidateConfig")]
++        private static extern int WebPValidateConfig_x86(ref WebPConfig config);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPValidateConfig")]
++        private static extern int WebPValidateConfig_x64(ref WebPConfig config);
++
++        /// <summary>Initialize the WebPPicture structure checking the DLL version</summary>
++        /// <param name="wpic">The WebPPicture structure</param>
++        /// <returns>1 if not error</returns>
++        internal static int WebPPictureInitInternal(ref WebPPicture wpic)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPPictureInitInternal_x86(ref wpic, WEBP_DECODER_ABI_VERSION);
++                case 8:
++                    return WebPPictureInitInternal_x64(ref wpic, WEBP_DECODER_ABI_VERSION);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureInitInternal")]
++        private static extern int WebPPictureInitInternal_x86(ref WebPPicture wpic, int WEBP_DECODER_ABI_VERSION);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureInitInternal")]
++        private static extern int WebPPictureInitInternal_x64(ref WebPPicture wpic, int WEBP_DECODER_ABI_VERSION);
++
++        /// <summary>Colorspace conversion function to import RGB samples</summary>
++        /// <param name="wpic">The WebPPicture structure</param>
++        /// <param name="bgr">Point to BGR data</param>
++        /// <param name="stride">stride of BGR data</param>
++        /// <returns>Returns 0 in case of memory error.</returns>
++        internal static int WebPPictureImportBGR(ref WebPPicture wpic, IntPtr bgr, int stride)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPPictureImportBGR_x86(ref wpic, bgr, stride);
++                case 8:
++                    return WebPPictureImportBGR_x64(ref wpic, bgr, stride);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureImportBGR")]
++        private static extern int WebPPictureImportBGR_x86(ref WebPPicture wpic, IntPtr bgr, int stride);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureImportBGR")]
++        private static extern int WebPPictureImportBGR_x64(ref WebPPicture wpic, IntPtr bgr, int stride);
++
++        /// <summary>Color-space conversion function to import RGB samples</summary>
++        /// <param name="wpic">The WebPPicture structure</param>
++        /// <param name="bgra">Point to BGRA data</param>
++        /// <param name="stride">stride of BGRA data</param>
++        /// <returns>Returns 0 in case of memory error.</returns>
++        internal static int WebPPictureImportBGRA(ref WebPPicture wpic, IntPtr bgra, int stride)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPPictureImportBGRA_x86(ref wpic, bgra, stride);
++                case 8:
++                    return WebPPictureImportBGRA_x64(ref wpic, bgra, stride);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureImportBGRA")]
++        private static extern int WebPPictureImportBGRA_x86(ref WebPPicture wpic, IntPtr bgra, int stride);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureImportBGRA")]
++        private static extern int WebPPictureImportBGRA_x64(ref WebPPicture wpic, IntPtr bgra, int stride);
++
++        /// <summary>Color-space conversion function to import RGB samples</summary>
++        /// <param name="wpic">The WebPPicture structure</param>
++        /// <param name="bgr">Point to BGR data</param>
++        /// <param name="stride">stride of BGR data</param>
++        /// <returns>Returns 0 in case of memory error.</returns>
++        internal static int WebPPictureImportBGRX(ref WebPPicture wpic, IntPtr bgr, int stride)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPPictureImportBGRX_x86(ref wpic, bgr, stride);
++                case 8:
++                    return WebPPictureImportBGRX_x64(ref wpic, bgr, stride);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureImportBGRX")]
++        private static extern int WebPPictureImportBGRX_x86(ref WebPPicture wpic, IntPtr bgr, int stride);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureImportBGRX")]
++        private static extern int WebPPictureImportBGRX_x64(ref WebPPicture wpic, IntPtr bgr, int stride);
++
++        /// <summary>The writer type for output compress data</summary>
++        /// <param name="data">Data returned</param>
++        /// <param name="data_size">Size of data returned</param>
++        /// <param name="wpic">Picture structure</param>
++        /// <returns></returns>
++        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
++        internal delegate int WebPMemoryWrite([In()] IntPtr data, UIntPtr data_size, ref WebPPicture wpic);
++        internal static WebPMemoryWrite OnCallback;
++
++        /// <summary>Compress to WebP format</summary>
++        /// <param name="config">The configuration structure for compression parameters</param>
++        /// <param name="picture">'picture' hold the source samples in both YUV(A) or ARGB input</param>
++        /// <returns>Returns 0 in case of error, 1 otherwise. In case of error, picture->error_code is updated accordingly.</returns>
++        internal static int WebPEncode(ref WebPConfig config, ref WebPPicture picture)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPEncode_x86(ref config, ref picture);
++                case 8:
++                    return WebPEncode_x64(ref config, ref picture);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncode")]
++        private static extern int WebPEncode_x86(ref WebPConfig config, ref WebPPicture picture);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncode")]
++        private static extern int WebPEncode_x64(ref WebPConfig config, ref WebPPicture picture);
++
++        /// <summary>Release the memory allocated by WebPPictureAlloc() or WebPPictureImport*()
++        /// Note that this function does _not_ free the memory used by the 'picture' object itself.
++        /// Besides memory (which is reclaimed) all other fields of 'picture' are preserved</summary>
++        /// <param name="picture">Picture structure</param>
++        internal static void WebPPictureFree(ref WebPPicture picture)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    WebPPictureFree_x86(ref picture);
++                    break;
++                case 8:
++                    WebPPictureFree_x64(ref picture);
++                    break;
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureFree")]
++        private static extern void WebPPictureFree_x86(ref WebPPicture wpic);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureFree")]
++        private static extern void WebPPictureFree_x64(ref WebPPicture wpic);
++
++        /// <summary>Validate the WebP image header and retrieve the image height and width. Pointers *width and *height can be passed NULL if deemed irrelevant</summary>
++        /// <param name="data">Pointer to WebP image data</param>
++        /// <param name="data_size">This is the size of the memory block pointed to by data containing the image data</param>
++        /// <param name="width">The range is limited currently from 1 to 16383</param>
++        /// <param name="height">The range is limited currently from 1 to 16383</param>
++        /// <returns>1 if success, otherwise error code returned in the case of (a) formatting error(s).</returns>
++        internal static int WebPGetInfo(IntPtr data, int data_size, out int width, out int height)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPGetInfo_x86(data, (UIntPtr)data_size, out width, out height);
++                case 8:
++                    return WebPGetInfo_x64(data, (UIntPtr)data_size, out width, out height);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPGetInfo")]
++        private static extern int WebPGetInfo_x86([InAttribute()] IntPtr data, UIntPtr data_size, out int width, out int height);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPGetInfo")]
++        private static extern int WebPGetInfo_x64([InAttribute()] IntPtr data, UIntPtr data_size, out int width, out int height);
++
++        /// <summary>Decode WEBP image pointed to by *data and returns BGR samples into a preallocated buffer</summary>
++        /// <param name="data">Pointer to WebP image data</param>
++        /// <param name="data_size">This is the size of the memory block pointed to by data containing the image data</param>
++        /// <param name="output_buffer">Pointer to decoded WebP image</param>
++        /// <param name="output_buffer_size">Size of allocated buffer</param>
++        /// <param name="output_stride">Specifies the distance between scan lines</param>
++        internal static void WebPDecodeBGRInto(IntPtr data, int data_size, IntPtr output_buffer, int output_buffer_size, int output_stride)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    if (WebPDecodeBGRInto_x86(data, (UIntPtr)data_size, output_buffer, output_buffer_size, output_stride) == null)
++                        throw new InvalidOperationException("Can not decode WebP");
++                    break;
++                case 8:
++                    if (WebPDecodeBGRInto_x64(data, (UIntPtr)data_size, output_buffer, output_buffer_size, output_stride) == null)
++                        throw new InvalidOperationException("Can not decode WebP");
++                    break;
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecodeBGRInto")]
++        private static extern IntPtr WebPDecodeBGRInto_x86([InAttribute()] IntPtr data, UIntPtr data_size, IntPtr output_buffer, int output_buffer_size, int output_stride);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecodeBGRInto")]
++        private static extern IntPtr WebPDecodeBGRInto_x64([InAttribute()] IntPtr data, UIntPtr data_size, IntPtr output_buffer, int output_buffer_size, int output_stride);
++
++        /// <summary>Decode WEBP image pointed to by *data and returns BGRA samples into a preallocated buffer</summary>
++        /// <param name="data">Pointer to WebP image data</param>
++        /// <param name="data_size">This is the size of the memory block pointed to by data containing the image data</param>
++        /// <param name="output_buffer">Pointer to decoded WebP image</param>
++        /// <param name="output_buffer_size">Size of allocated buffer</param>
++        /// <param name="output_stride">Specifies the distance between scan lines</param>
++        internal static void WebPDecodeBGRAInto(IntPtr data, int data_size, IntPtr output_buffer, int output_buffer_size, int output_stride)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    if (WebPDecodeBGRAInto_x86(data, (UIntPtr)data_size, output_buffer, output_buffer_size, output_stride) == null)
++                        throw new InvalidOperationException("Can not decode WebP"); 
++                    break;
++                case 8:
++                    if (WebPDecodeBGRAInto_x64(data, (UIntPtr)data_size, output_buffer, output_buffer_size, output_stride) == null)
++                        throw new InvalidOperationException("Can not decode WebP");
++                    break;
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecodeBGRAInto")]
++        private static extern IntPtr WebPDecodeBGRAInto_x86([InAttribute()] IntPtr data, UIntPtr data_size, IntPtr output_buffer, int output_buffer_size, int output_stride);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecodeBGRAInto")]
++        private static extern IntPtr WebPDecodeBGRAInto_x64([InAttribute()] IntPtr data, UIntPtr data_size, IntPtr output_buffer, int output_buffer_size, int output_stride);
++
++        /// <summary>Decode WEBP image pointed to by *data and returns ARGB samples into a preallocated buffer</summary>
++        /// <param name="data">Pointer to WebP image data</param>
++        /// <param name="data_size">This is the size of the memory block pointed to by data containing the image data</param>
++        /// <param name="output_buffer">Pointer to decoded WebP image</param>
++        /// <param name="output_buffer_size">Size of allocated buffer</param>
++        /// <param name="output_stride">Specifies the distance between scan lines</param>
++        internal static void WebPDecodeARGBInto(IntPtr data, int data_size, IntPtr output_buffer, int output_buffer_size, int output_stride)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    if (WebPDecodeARGBInto_x86(data, (UIntPtr)data_size, output_buffer, output_buffer_size, output_stride) == null)
++                        throw new InvalidOperationException("Can not decode WebP");
++                    break;
++                case 8:
++                    if (WebPDecodeARGBInto_x64(data, (UIntPtr)data_size, output_buffer, output_buffer_size, output_stride) == null)
++                        throw new InvalidOperationException("Can not decode WebP");
++                    break;
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecodeARGBInto")]
++        private static extern IntPtr WebPDecodeARGBInto_x86([InAttribute()] IntPtr data, UIntPtr data_size, IntPtr output_buffer, int output_buffer_size, int output_stride);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecodeARGBInto")]
++        private static extern IntPtr WebPDecodeARGBInto_x64([InAttribute()] IntPtr data, UIntPtr data_size, IntPtr output_buffer, int output_buffer_size, int output_stride);
++
++        /// <summary>Initialize the configuration as empty. This function must always be called first, unless WebPGetFeatures() is to be called</summary>
++        /// <param name="webPDecoderConfig">Configuration structure</param>
++        /// <returns>False in case of mismatched version.</returns>
++        internal static int WebPInitDecoderConfig(ref WebPDecoderConfig webPDecoderConfig)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPInitDecoderConfigInternal_x86(ref webPDecoderConfig, WEBP_DECODER_ABI_VERSION);
++                case 8:
++                    return WebPInitDecoderConfigInternal_x64(ref webPDecoderConfig, WEBP_DECODER_ABI_VERSION);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPInitDecoderConfigInternal")]
++        private static extern int WebPInitDecoderConfigInternal_x86(ref WebPDecoderConfig webPDecoderConfig, int WEBP_DECODER_ABI_VERSION);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPInitDecoderConfigInternal")]
++        private static extern int WebPInitDecoderConfigInternal_x64(ref WebPDecoderConfig webPDecoderConfig, int WEBP_DECODER_ABI_VERSION);
++
++        /// <summary>Decodes the full data at once, taking configuration into account</summary>
++        /// <param name="data">WebP raw data to decode</param>
++        /// <param name="data_size">Size of WebP data </param>
++        /// <param name="webPDecoderConfig">Configuration structure</param>
++        /// <returns>VP8_STATUS_OK if the decoding was successful</returns>
++        internal static VP8StatusCode WebPDecode(IntPtr data, int data_size, ref WebPDecoderConfig webPDecoderConfig)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPDecode_x86(data, (UIntPtr)data_size, ref webPDecoderConfig);
++                case 8:
++                    return WebPDecode_x64(data, (UIntPtr)data_size, ref webPDecoderConfig);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecode")]
++        private static extern VP8StatusCode WebPDecode_x86(IntPtr data, UIntPtr data_size, ref WebPDecoderConfig config);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPDecode")]
++        private static extern VP8StatusCode WebPDecode_x64(IntPtr data, UIntPtr data_size, ref WebPDecoderConfig config);
++
++        /// <summary>Free any memory associated with the buffer. Must always be called last. Doesn't free the 'buffer' structure itself</summary>
++        /// <param name="buffer">WebPDecBuffer</param>
++        internal static void WebPFreeDecBuffer(ref WebPDecBuffer buffer)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    WebPFreeDecBuffer_x86(ref buffer);
++                    break;
++                case 8:
++                    WebPFreeDecBuffer_x64(ref buffer);
++                    break;
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPFreeDecBuffer")]
++        private static extern void WebPFreeDecBuffer_x86(ref WebPDecBuffer buffer);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPFreeDecBuffer")]
++        private static extern void WebPFreeDecBuffer_x64(ref WebPDecBuffer buffer);
++
++        /// <summary>Lossy encoding images</summary>
++        /// <param name="bgr">Pointer to BGR image data</param>
++        /// <param name="width">The range is limited currently from 1 to 16383</param>
++        /// <param name="height">The range is limited currently from 1 to 16383</param>
++        /// <param name="stride">Specifies the distance between scanlines</param>
++        /// <param name="quality_factor">Ranges from 0 (lower quality) to 100 (highest quality). Controls the loss and quality during compression</param>
++        /// <param name="output">output_buffer with WebP image</param>
++        /// <returns>Size of WebP Image or 0 if an error occurred</returns>
++        internal static int WebPEncodeBGR(IntPtr bgr, int width, int height, int stride, float quality_factor, out IntPtr output)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPEncodeBGR_x86(bgr, width, height, stride, quality_factor, out output);
++                case 8:
++                    return WebPEncodeBGR_x64(bgr, width, height, stride, quality_factor, out output);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeBGR")]
++        private static extern int WebPEncodeBGR_x86([InAttribute()] IntPtr bgr, int width, int height, int stride, float quality_factor, out IntPtr output);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeBGR")]
++        private static extern int WebPEncodeBGR_x64([InAttribute()] IntPtr bgr, int width, int height, int stride, float quality_factor, out IntPtr output);
++
++        /// <summary>Lossy encoding images</summary>
++        /// <param name="bgr">Pointer to BGRA image data</param>
++        /// <param name="width">The range is limited currently from 1 to 16383</param>
++        /// <param name="height">The range is limited currently from 1 to 16383</param>
++        /// <param name="stride">Specifies the distance between scan lines</param>
++        /// <param name="quality_factor">Ranges from 0 (lower quality) to 100 (highest quality). Controls the loss and quality during compression</param>
++        /// <param name="output">output_buffer with WebP image</param>
++        /// <returns>Size of WebP Image or 0 if an error occurred</returns>
++        internal static int WebPEncodeBGRA(IntPtr bgra, int width, int height, int stride, float quality_factor, out IntPtr output)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPEncodeBGRA_x86(bgra, width, height, stride, quality_factor, out output);
++                case 8:
++                    return WebPEncodeBGRA_x64(bgra, width, height, stride, quality_factor, out output);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeBGRA")]
++        private static extern int WebPEncodeBGRA_x86([InAttribute()] IntPtr bgra, int width, int height, int stride, float quality_factor, out IntPtr output);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeBGRA")]
++        private static extern int WebPEncodeBGRA_x64([InAttribute()] IntPtr bgra, int width, int height, int stride, float quality_factor, out IntPtr output);
++
++        /// <summary>Lossless encoding images pointed to by *data in WebP format</summary>
++        /// <param name="bgr">Pointer to BGR image data</param>
++        /// <param name="width">The range is limited currently from 1 to 16383</param>
++        /// <param name="height">The range is limited currently from 1 to 16383</param>
++        /// <param name="stride">Specifies the distance between scan lines</param>
++        /// <param name="output">output_buffer with WebP image</param>
++        /// <returns>Size of WebP Image or 0 if an error occurred</returns>
++        internal static int WebPEncodeLosslessBGR(IntPtr bgr, int width, int height, int stride, out IntPtr output)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPEncodeLosslessBGR_x86(bgr, width, height, stride, out output);
++                case 8:
++                    return WebPEncodeLosslessBGR_x64(bgr, width, height, stride, out output);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeLosslessBGR")]
++        private static extern int WebPEncodeLosslessBGR_x86([InAttribute()] IntPtr bgr, int width, int height, int stride, out IntPtr output);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeLosslessBGR")]
++        private static extern int WebPEncodeLosslessBGR_x64([InAttribute()] IntPtr bgr, int width, int height, int stride, out IntPtr output);
++
++        /// <summary>Lossless encoding images pointed to by *data in WebP format</summary>
++        /// <param name="bgra">Pointer to BGRA image data</param>
++        /// <param name="width">The range is limited currently from 1 to 16383</param>
++        /// <param name="height">The range is limited currently from 1 to 16383</param>
++        /// <param name="stride">Specifies the distance between scan lines</param>
++        /// <param name="output">output_buffer with WebP image</param>
++        /// <returns>Size of WebP Image or 0 if an error occurred</returns>
++        internal static int WebPEncodeLosslessBGRA(IntPtr bgra, int width, int height, int stride, out IntPtr output)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPEncodeLosslessBGRA_x86(bgra, width, height, stride, out output);
++                case 8:
++                    return WebPEncodeLosslessBGRA_x64(bgra, width, height, stride, out output);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeLosslessBGRA")]
++        private static extern int WebPEncodeLosslessBGRA_x86([InAttribute()] IntPtr bgra, int width, int height, int stride, out IntPtr output);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPEncodeLosslessBGRA")]
++        private static extern int WebPEncodeLosslessBGRA_x64([InAttribute()] IntPtr bgra, int width, int height, int stride, out IntPtr output);
++
++        /// <summary>Releases memory returned by the WebPEncode</summary>
++        /// <param name="p">Pointer to memory</param>
++        internal static void WebPFree(IntPtr p)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    WebPFree_x86(p);
++                    break;
++                case 8:
++                    WebPFree_x64(p);
++                    break;
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPFree")]
++        private static extern void WebPFree_x86(IntPtr p);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPFree")]
++        private static extern void WebPFree_x64(IntPtr p);
++
++        /// <summary>Get the WebP version library</summary>
++        /// <returns>8bits for each of major/minor/revision packet in integer. E.g: v2.5.7 is 0x020507</returns>
++        internal static int WebPGetDecoderVersion()
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPGetDecoderVersion_x86();
++                case 8:
++                    return WebPGetDecoderVersion_x64();
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPGetDecoderVersion")]
++        private static extern int WebPGetDecoderVersion_x86();
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPGetDecoderVersion")]
++        private static extern int WebPGetDecoderVersion_x64();
++
++        /// <summary>Compute PSNR, SSIM or LSIM distortion metric between two pictures</summary>
++        /// <param name="srcPicture">Picture to measure</param>
++        /// <param name="refPicture">Reference picture</param>
++        /// <param name="metric_type">0 = PSNR, 1 = SSIM, 2 = LSIM</param>
++        /// <param name="pResult">dB in the Y/U/V/Alpha/All order</param>
++        /// <returns>False in case of error (the two pictures don't have same dimension, ...)</returns>
++        internal static int WebPPictureDistortion(ref WebPPicture srcPicture, ref WebPPicture refPicture, int metric_type, IntPtr pResult)
++        {
++            switch (IntPtr.Size)
++            {
++                case 4:
++                    return WebPPictureDistortion_x86(ref srcPicture, ref refPicture, metric_type, pResult);
++                case 8:
++                    return WebPPictureDistortion_x64(ref srcPicture, ref refPicture, metric_type, pResult);
++                default:
++                    throw new InvalidOperationException("Invalid platform. Can not find proper function");
++            }
++        }
++        [DllImport("libwebp_x86.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureDistortion")]
++        private static extern int WebPPictureDistortion_x86(ref WebPPicture srcPicture, ref WebPPicture refPicture, int metric_type, IntPtr pResult);
++        [DllImport("libwebp.dll", CallingConvention = CallingConvention.Cdecl, EntryPoint = "WebPPictureDistortion")]
++        private static extern int WebPPictureDistortion_x64(ref WebPPicture srcPicture, ref WebPPicture refPicture, int metric_type, IntPtr pResult);
++    }
++    #endregion
++
++    #region | Predefined |
++    /// <summary>Enumerate some predefined settings for WebPConfig, depending on the type of source picture. These presets are used when calling WebPConfigPreset()</summary>
++    internal enum WebPPreset
++    {
++        /// <summary>Default preset</summary>
++        WEBP_PRESET_DEFAULT = 0,
++        /// <summary>Digital picture, like portrait, inner shot</summary>
++        WEBP_PRESET_PICTURE,
++        /// <summary>Outdoor photograph, with natural lighting</summary>
++        WEBP_PRESET_PHOTO,
++        /// <summary>Hand or line drawing, with high-contrast details</summary>
++        WEBP_PRESET_DRAWING,
++        /// <summary>Small-sized colorful images</summary>
++        WEBP_PRESET_ICON,
++        /// <summary>Text-like</summary>
++        WEBP_PRESET_TEXT
++    };
++
++    /// <summary>Encoding error conditions</summary>
++    internal enum WebPEncodingError
++    {
++        /// <summary>No error</summary>
++        VP8_ENC_OK = 0,
++        /// <summary>Memory error allocating objects</summary>
++        VP8_ENC_ERROR_OUT_OF_MEMORY,
++        /// <summary>Memory error while flushing bits</summary>
++        VP8_ENC_ERROR_BITSTREAM_OUT_OF_MEMORY,
++        /// <summary>A pointer parameter is NULL</summary>
++        VP8_ENC_ERROR_NULL_PARAMETER,
++        /// <summary>Configuration is invalid</summary>
++        VP8_ENC_ERROR_INVALID_CONFIGURATION,
++        /// <summary>Picture has invalid width/height</summary>
++        VP8_ENC_ERROR_BAD_DIMENSION,
++        /// <summary>Partition is bigger than 512k</summary>
++        VP8_ENC_ERROR_PARTITION0_OVERFLOW,
++        /// <summary>Partition is bigger than 16M</summary>
++        VP8_ENC_ERROR_PARTITION_OVERFLOW,
++        /// <summary>Error while flushing bytes</summary>
++        VP8_ENC_ERROR_BAD_WRITE,
++        /// <summary>File is bigger than 4G</summary>
++        VP8_ENC_ERROR_FILE_TOO_BIG,
++        /// <summary>Abort request by user</summary>
++        VP8_ENC_ERROR_USER_ABORT,
++        /// <summary>List terminator. Always last</summary>
++        VP8_ENC_ERROR_LAST,
++    }
++
++    /// <summary>Enumeration of the status codes</summary>
++    internal enum VP8StatusCode
++    {
++        /// <summary>No error</summary>
++        VP8_STATUS_OK = 0,
++        /// <summary>Memory error allocating objects</summary>
++        VP8_STATUS_OUT_OF_MEMORY,
++        /// <summary>Configuration is invalid</summary>
++        VP8_STATUS_INVALID_PARAM,
++        VP8_STATUS_BITSTREAM_ERROR,
++        /// <summary>Configuration is invalid</summary>
++        VP8_STATUS_UNSUPPORTED_FEATURE,
++        VP8_STATUS_SUSPENDED,
++        /// <summary>Abort request by user</summary>
++        VP8_STATUS_USER_ABORT,
++        VP8_STATUS_NOT_ENOUGH_DATA,
++    }
++
++    /// <summary>Image characteristics hint for the underlying encoder</summary>
++    internal enum WebPImageHint
++    {
++        /// <summary>Default preset</summary>
++        WEBP_HINT_DEFAULT = 0,
++        /// <summary>Digital picture, like portrait, inner shot</summary>
++        WEBP_HINT_PICTURE,
++        /// <summary>Outdoor photograph, with natural lighting</summary>
++        WEBP_HINT_PHOTO,
++        /// <summary>Discrete tone image (graph, map-tile etc)</summary>
++        WEBP_HINT_GRAPH,
++        /// <summary>List terminator. Always last</summary>
++        WEBP_HINT_LAST
++    };
++
++    /// <summary>Describes the byte-ordering of packed samples in memory</summary>
++    internal enum WEBP_CSP_MODE
++    {
++        /// <summary>Byte-order: R,G,B,R,G,B,..</summary>
++        MODE_RGB = 0,
++        /// <summary>Byte-order: R,G,B,A,R,G,B,A,..</summary>
++        MODE_RGBA = 1,
++        /// <summary>Byte-order: B,G,R,B,G,R,..</summary>
++        MODE_BGR = 2,
++        /// <summary>Byte-order: B,G,R,A,B,G,R,A,..</summary>
++        MODE_BGRA = 3,
++        /// <summary>Byte-order: A,R,G,B,A,R,G,B,..</summary>
++        MODE_ARGB = 4,
++        /// <summary>Byte-order: RGB-565: [a4 a3 a2 a1 a0 r5 r4 r3], [r2 r1 r0 g4 g3 g2 g1 g0], ...
++        /// WEBP_SWAP_16BITS_CSP is defined, 
++        /// Byte-order: RGB-565: [a4 a3 a2 a1 a0 b5 b4 b3], [b2 b1 b0 g4 g3 g2 g1 g0], ..</summary>
++        MODE_RGBA_4444 = 5,
++        /// <summary>Byte-order: RGB-565: [r4 r3 r2 r1 r0 g5 g4 g3], [g2 g1 g0 b4 b3 b2 b1 b0], ...
++        /// WEBP_SWAP_16BITS_CSP is defined, 
++        /// Byte-order: [b3 b2 b1 b0 a3 a2 a1 a0], [r3 r2 r1 r0 g3 g2 g1 g0], ..</summary>
++        MODE_RGB_565 = 6,
++        /// <summary>RGB-premultiplied transparent modes (alpha value is preserved)</summary>
++        MODE_rgbA = 7,
++        /// <summary>RGB-premultiplied transparent modes (alpha value is preserved)</summary>
++        MODE_bgrA = 8,
++        /// <summary>RGB-premultiplied transparent modes (alpha value is preserved)</summary>
++        MODE_Argb = 9,
++        /// <summary>RGB-premultiplied transparent modes (alpha value is preserved)</summary>
++        MODE_rgbA_4444 = 10,
++        /// <summary>YUV 4:2:0</summary>
++        MODE_YUV = 11,
++        /// <summary>YUV 4:2:0</summary>
++        MODE_YUVA = 12,
++        /// <summary>MODE_LAST -> 13</summary>
++        MODE_LAST = 13,
++    }
++
++    /// <summary>
++    /// Decoding states. State normally flows as:
++    /// WEBP_HEADER->VP8_HEADER->VP8_PARTS0->VP8_DATA->DONE for a lossy image, and
++    /// WEBP_HEADER->VP8L_HEADER->VP8L_DATA->DONE for a lossless image.
++    /// If there is any error the decoder goes into state ERROR.
++    /// </summary>
++    internal enum DecState
++    {
++        STATE_WEBP_HEADER,  // All the data before that of the VP8/VP8L chunk.
++        STATE_VP8_HEADER,   // The VP8 Frame header (within the VP8 chunk).
++        STATE_VP8_PARTS0,
++        STATE_VP8_DATA,
++        STATE_VP8L_HEADER,
++        STATE_VP8L_DATA,
++        STATE_DONE,
++        STATE_ERROR
++    };
++    #endregion
++
++    #region | libwebp structs |
++    /// <summary>Features gathered from the bit stream</summary>
++    [StructLayoutAttribute(LayoutKind.Sequential)]
++    internal struct WebPBitstreamFeatures
++    {
++        /// <summary>Width in pixels, as read from the bit stream</summary>
++        public int Width;
++        /// <summary>Height in pixels, as read from the bit stream</summary>
++        public int Height;
++        /// <summary>True if the bit stream contains an alpha channel</summary>
++        public int Has_alpha;
++        /// <summary>True if the bit stream is an animation</summary>
++        public int Has_animation;
++        /// <summary>0 = undefined (/mixed), 1 = lossy, 2 = lossless</summary>
++        public int Format;
++        /// <summary>Padding for later use</summary>
++        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 5, ArraySubType = UnmanagedType.U4)]
++        private readonly uint[] pad;
++    };
++
++    /// <summary>Compression parameters</summary>
++    [StructLayoutAttribute(LayoutKind.Sequential)]
++    internal struct WebPConfig
++    {
++        /// <summary>Lossless encoding (0=lossy(default), 1=lossless)</summary>
++        public int lossless;
++        /// <summary>Between 0 (smallest file) and 100 (biggest)</summary>
++        public float quality;
++        /// <summary>Quality/speed trade-off (0=fast, 6=slower-better)</summary>
++        public int method;
++        /// <summary>Hint for image type (lossless only for now)</summary>
++        public WebPImageHint image_hint;
++        /// <summary>If non-zero, set the desired target size in bytes. Takes precedence over the 'compression' parameter</summary>
++        public int target_size;
++        /// <summary>If non-zero, specifies the minimal distortion to try to achieve. Takes precedence over target_size</summary>
++        public float target_PSNR;
++        /// <summary>Maximum number of segments to use, in [1..4]</summary>
++        public int segments;
++        /// <summary>Spatial Noise Shaping. 0=off, 100=maximum</summary>
++        public int sns_strength;
++        /// <summary>Range: [0 = off .. 100 = strongest]</summary>
++        public int filter_strength;
++        /// <summary>Range: [0 = off .. 7 = least sharp]</summary>
++        public int filter_sharpness;
++        /// <summary>Filtering type: 0 = simple, 1 = strong (only used if filter_strength > 0 or auto-filter > 0)</summary>
++        public int filter_type;
++        /// <summary>Auto adjust filter's strength [0 = off, 1 = on]</summary>
++        public int autofilter;
++        /// <summary>Algorithm for encoding the alpha plane (0 = none, 1 = compressed with WebP lossless). Default is 1</summary>
++        public int alpha_compression;
++        /// <summary>Predictive filtering method for alpha plane. 0: none, 1: fast, 2: best. Default if 1</summary>
++        public int alpha_filtering;
++        /// <summary>Between 0 (smallest size) and 100 (lossless). Default is 100</summary>
++        public int alpha_quality;
++        /// <summary>Number of entropy-analysis passes (in [1..10])</summary>
++        public int pass;
++        /// <summary>If true, export the compressed picture back. In-loop filtering is not applied</summary>
++        public int show_compressed;
++        /// <summary>Preprocessing filter (0=none, 1=segment-smooth, 2=pseudo-random dithering)</summary>
++        public int preprocessing;
++        /// <summary>Log2(number of token partitions) in [0..3] Default is set to 0 for easier progressive decoding</summary>
++        public int partitions;
++        /// <summary>Quality degradation allowed to fit the 512k limit on prediction modes coding (0: no degradation, 100: maximum possible degradation)</summary>
++        public int partition_limit;
++        /// <summary>If true, compression parameters will be remapped to better match the expected output size from JPEG compression. Generally, the output size will be similar but the degradation will be lower</summary>
++        public int emulate_jpeg_size;
++        /// <summary>If non-zero, try and use multi-threaded encoding</summary>
++        public int thread_level;
++        /// <summary>If set, reduce memory usage (but increase CPU use)</summary>
++        public int low_memory;
++        /// <summary>Near lossless encoding [0 = max loss .. 100 = off (default)]</summary>
++        public int near_lossless;
++        /// <summary>If non-zero, preserve the exact RGB values under transparent area. Otherwise, discard this invisible RGB information for better compression. The default value is 0</summary>
++        public int exact;
++        /// <summary>Reserved for future lossless feature</summary>
++        public int delta_palettization;
++        /// <summary>If needed, use sharp (and slow) RGB->YUV conversion</summary>
++        public int use_sharp_yuv;
++        /// <summary>Padding for later use</summary>
++        private readonly int pad1;
++        private readonly int pad2;
++    };
++
++    /// <summary>Main exchange structure (input samples, output bytes, statistics)</summary>
++    [StructLayoutAttribute(LayoutKind.Sequential)]
++    internal struct WebPPicture
++    {
++        /// <summary>Main flag for encoder selecting between ARGB or YUV input. Recommended to use ARGB input (*argb, argb_stride) for lossless, and YUV input (*y, *u, *v, etc.) for lossy</summary>
++        public int use_argb;
++        /// <summary>Color-space: should be YUV420 for now (=Y'CbCr). Value = 0</summary>
++        public UInt32 colorspace;
++        /// <summary>Width of picture (less or equal to WEBP_MAX_DIMENSION)</summary>
++        public int width;
++        /// <summary>Height of picture (less or equal to WEBP_MAX_DIMENSION)</summary>
++        public int height;
++        /// <summary>Pointer to luma plane</summary>
++        public IntPtr y;
++        /// <summary>Pointer to chroma U plane</summary>
++        public IntPtr u;
++        /// <summary>Pointer to chroma V plane</summary>
++        public IntPtr v;
++        /// <summary>Luma stride</summary>
++        public int y_stride;
++        /// <summary>Chroma stride</summary>
++        public int uv_stride;
++        /// <summary>Pointer to the alpha plane</summary>
++        public IntPtr a;
++        /// <summary>stride of the alpha plane</summary>
++        public int a_stride;
++        /// <summary>Padding for later use</summary>
++        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.U4)]
++        private readonly uint[] pad1;
++        /// <summary>Pointer to ARGB (32 bit) plane</summary>
++        public IntPtr argb;
++        /// <summary>This is stride in pixels units, not bytes</summary>
++        public int argb_stride;
++        /// <summary>Padding for later use</summary>
++        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 3, ArraySubType = UnmanagedType.U4)]
++        private readonly uint[] pad2;
++        /// <summary>Byte-emission hook, to store compressed bytes as they are ready</summary>
++        public IntPtr writer;
++        /// <summary>Can be used by the writer</summary>
++        public IntPtr custom_ptr;
++        // map for extra information (only for lossy compression mode)
++        /// <summary>1: intra type, 2: segment, 3: quant, 4: intra-16 prediction mode, 5: chroma prediction mode, 6: bit cost, 7: distortion</summary>
++        public int extra_info_type;
++        /// <summary>If not NULL, points to an array of size ((width + 15) / 16) * ((height + 15) / 16) that will be filled with a macroblock map, depending on extra_info_type</summary>
++        public IntPtr extra_info;
++        /// <summary>Pointer to side statistics (updated only if not NULL)</summary>
++        public IntPtr stats;
++        /// <summary>Error code for the latest error encountered during encoding</summary>
++        public UInt32 error_code;
++        /// <summary>If not NULL, report progress during encoding</summary>
++        public IntPtr progress_hook;
++        /// <summary>This field is free to be set to any value and used during callbacks (like progress-report e.g.)</summary>
++        public IntPtr user_data;
++        /// <summary>Padding for later use</summary>
++        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 13, ArraySubType = UnmanagedType.U4)]
++        private readonly uint[] pad3;
++        /// <summary>Row chunk of memory for YUVA planes</summary>
++        private readonly IntPtr memory_;
++        /// <summary>Row chunk of memory for ARGB planes</summary>
++        private readonly IntPtr memory_argb_;
++        /// <summary>Padding for later use</summary>
++        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.U4)]
++        private readonly uint[] pad4;
++    };
++
++    /// <summary>Structure for storing auxiliary statistics (mostly for lossy encoding)</summary>
++    [StructLayoutAttribute(LayoutKind.Sequential)]
++    internal struct WebPAuxStats
++    {
++        /// <summary>Final size</summary>
++        public int coded_size;
++        /// <summary>Peak-signal-to-noise ratio for Y</summary>
++        public float PSNRY;
++        /// <summary>Peak-signal-to-noise ratio for U</summary>
++        public float PSNRU;
++        /// <summary>Peak-signal-to-noise ratio for V</summary>
++        public float PSNRV;
++        /// <summary>Peak-signal-to-noise ratio for All</summary>
++        public float PSNRALL;
++        /// <summary>Peak-signal-to-noise ratio for Alpha</summary>
++        public float PSNRAlpha;
++        /// <summary>Number of intra4</summary>
++        public int block_count_intra4;
++        /// <summary>Number of intra16</summary>
++        public int block_count_intra16;
++        /// <summary>Number of skipped macro-blocks</summary>
++        public int block_count_skipped;
++        /// <summary>Approximate number of bytes spent for header</summary>
++        public int header_bytes;
++        /// <summary>Approximate number of bytes spent for  mode-partition #0</summary>
++        public int mode_partition_0;
++        /// <summary>Approximate number of bytes spent for DC coefficients for segment 0</summary>
++        public int residual_bytes_DC_segments0;
++        /// <summary>Approximate number of bytes spent for AC coefficients for segment 0</summary>
++        public int residual_bytes_AC_segments0;
++        /// <summary>Approximate number of bytes spent for UV coefficients for segment 0</summary>
++        public int residual_bytes_uv_segments0;
++        /// <summary>Approximate number of bytes spent for DC coefficients for segment 1</summary>
++        public int residual_bytes_DC_segments1;
++        /// <summary>Approximate number of bytes spent for AC coefficients for segment 1</summary>
++        public int residual_bytes_AC_segments1;
++        /// <summary>Approximate number of bytes spent for UV coefficients for segment 1</summary>
++        public int residual_bytes_uv_segments1;
++        /// <summary>Approximate number of bytes spent for DC coefficients for segment 2</summary>
++        public int residual_bytes_DC_segments2;
++        /// <summary>Approximate number of bytes spent for AC coefficients for segment 2</summary>
++        public int residual_bytes_AC_segments2;
++        /// <summary>Approximate number of bytes spent for UV coefficients for segment 2</summary>
++        public int residual_bytes_uv_segments2;
++        /// <summary>Approximate number of bytes spent for DC coefficients for segment 3</summary>
++        public int residual_bytes_DC_segments3;
++        /// <summary>Approximate number of bytes spent for AC coefficients for segment 3</summary>
++        public int residual_bytes_AC_segments3;
++        /// <summary>Approximate number of bytes spent for UV coefficients for segment 3</summary>
++        public int residual_bytes_uv_segments3;
++        /// <summary>Number of macro-blocks in segments 0</summary>
++        public int segment_size_segments0;
++        /// <summary>Number of macro-blocks in segments 1</summary>
++        public int segment_size_segments1;
++        /// <summary>Number of macro-blocks in segments 2</summary>
++        public int segment_size_segments2;
++        /// <summary>Number of macro-blocks in segments 3</summary>
++        public int segment_size_segments3;
++        /// <summary>Quantizer values for segment 0</summary>
++        public int segment_quant_segments0;
++        /// <summary>Quantizer values for segment 1</summary>
++        public int segment_quant_segments1;
++        /// <summary>Quantizer values for segment 2</summary>
++        public int segment_quant_segments2;
++        /// <summary>Quantizer values for segment 3</summary>
++        public int segment_quant_segments3;
++        /// <summary>Filtering strength for segment 0 [0..63]</summary>
++        public int segment_level_segments0;
++        /// <summary>Filtering strength for segment 1 [0..63]</summary>
++        public int segment_level_segments1;
++        /// <summary>Filtering strength for segment 2 [0..63]</summary>
++        public int segment_level_segments2;
++        /// <summary>Filtering strength for segment 3 [0..63]</summary>
++        public int segment_level_segments3;
++        /// <summary>Size of the transparency data</summary>
++        public int alpha_data_size;
++        /// <summary>Size of the enhancement layer data</summary>
++        public int layer_data_size;
++
++        // lossless encoder statistics
++        /// <summary>bit0:predictor bit1:cross-color transform bit2:subtract-green bit3:color indexing</summary>
++        public Int32 lossless_features;
++        /// <summary>Number of precision bits of histogram</summary>
++        public int histogram_bits;
++        /// <summary>Precision bits for transform</summary>
++        public int transform_bits;
++        /// <summary>Number of bits for color cache lookup</summary>
++        public int cache_bits;
++        /// <summary>Number of color in palette, if used</summary>
++        public int palette_size;
++        /// <summary>Final lossless size</summary>
++        public int lossless_size;
++        /// <summary>Lossless header (transform, Huffman, etc) size</summary>
++        public int lossless_hdr_size;
++        /// <summary>Lossless image data size</summary>
++        public int lossless_data_size;
++        /// <summary>Padding for later use</summary>
++        [MarshalAsAttribute(UnmanagedType.ByValArray, SizeConst = 2, ArraySubType = UnmanagedType.U4)]
++        private readonly uint[] pad;
++    };
++
++    [StructLayoutAttribute(LayoutKind.Sequential)]
++    internal struct WebPDecoderConfig
++    {
++        /// <summary>Immutable bit stream features (optional)</summary>
++        public WebPBitstreamFeatures input;
++        /// <summary>Output buffer (can point to external memory)</summary>
++        public WebPDecBuffer output;
++        /// <summary>Decoding options</summary>
++        public WebPDecoderOptions options;
++    }
++
++    /// <summary>Output buffer</summary>
++    [StructLayoutAttribute(LayoutKind.Sequential)]
++    internal struct WebPDecBuffer
++    {
++        /// <summary>Color space</summary>
++        public WEBP_CSP_MODE colorspace;
++        /// <summary>Width of image</summary>
++        public int width;
++        /// <summary>Height of image</summary>
++        public int height;
++        /// <summary>If non-zero, 'internal_memory' pointer is not used. If value is '2' or more, the external memory is considered 'slow' and multiple read/write will be avoided</summary>
++        public int is_external_memory;
++        /// <summary>Output buffer parameters</summary>
++        public RGBA_YUVA_Buffer u;
++        /// <summary>Padding for later use</summary>
++        private readonly UInt32 pad1;
++        /// <summary>Padding for later use</summary>
++        private readonly UInt32 pad2;
++        /// <summary>Padding for later use</summary>
++        private readonly UInt32 pad3;
++        /// <summary>Padding for later use</summary>
++        private readonly UInt32 pad4;
++        /// <summary>Internally allocated memory (only when is_external_memory is 0). Should not be used externally, but accessed via WebPRGBABuffer</summary>
++        public IntPtr private_memory;
++    }
++
++    /// <summary>Union of buffer parameters</summary>
++    [StructLayoutAttribute(LayoutKind.Explicit)]
++    internal struct RGBA_YUVA_Buffer
++    {
++        [FieldOffsetAttribute(0)]
++        public WebPRGBABuffer RGBA;
++
++        [FieldOffsetAttribute(0)]
++        public WebPYUVABuffer YUVA;
++    }
++
++    [StructLayoutAttribute(LayoutKind.Sequential)]
++    internal struct WebPYUVABuffer
++    {
++        /// <summary>Pointer to luma samples</summary>
++        public IntPtr y;
++        /// <summary>Pointer to chroma U samples</summary>
++        public IntPtr u;
++        /// <summary>Pointer to chroma V samples</summary>
++        public IntPtr v;
++        /// <summary>Pointer to alpha samples</summary>
++        public IntPtr a;
++        /// <summary>Luma stride</summary>
++        public int y_stride;
++        /// <summary>Chroma U stride</summary>
++        public int u_stride;
++        /// <summary>Chroma V stride</summary>
++        public int v_stride;
++        /// <summary>Alpha stride</summary>
++        public int a_stride;
++        /// <summary>Luma plane size</summary>
++        public UIntPtr y_size;
++        /// <summary>Chroma plane U size</summary>
++        public UIntPtr u_size;
++        /// <summary>Chroma plane V size</summary>
++        public UIntPtr v_size;
++        /// <summary>Alpha plane size</summary>
++        public UIntPtr a_size;
++    }
++
++    /// <summary>Generic structure for describing the output sample buffer</summary>
++    [StructLayoutAttribute(LayoutKind.Sequential)]
++    internal struct WebPRGBABuffer
++    {
++        /// <summary>Pointer to RGBA samples</summary>
++        public IntPtr rgba;
++        /// <summary>Stride in bytes from one scanline to the next</summary>
++        public int stride;
++        /// <summary>Total size of the RGBA buffer</summary>
++        public UIntPtr size;
++    }
++
++    /// <summary>Decoding options</summary>
++    [StructLayout(LayoutKind.Sequential)]
++    public struct WebPDecoderOptions
++    {
++        /// <summary>If true, skip the in-loop filtering</summary>
++        public int bypass_filtering;
++        /// <summary>If true, use faster point-wise up-sampler</summary>
++        public int no_fancy_upsampling;
++        /// <summary>If true, cropping is applied _first_</summary>
++        public int use_cropping;
++        /// <summary>Left position for cropping. Will be snapped to even values</summary>
++        public int crop_left;
++        /// <summary>Top position for cropping. Will be snapped to even values</summary>
++        public int crop_top;
++        /// <summary>Width of the cropping area</summary>
++        public int crop_width;
++        /// <summary>Height of the cropping area</summary>
++        public int crop_height;
++        /// <summary>If true, scaling is applied _afterward_</summary>
++        public int use_scaling;
++        /// <summary>Final width</summary>
++        public int scaled_width;
++        /// <summary>Final height</summary>
++        public int scaled_height;
++        /// <summary>If true, use multi-threaded decoding</summary>
++        public int use_threads;
++        /// <summary>Dithering strength (0=Off, 100=full)</summary>
++        public int dithering_strength;
++        /// <summary>Flip output vertically</summary>
++        public int flip;
++        /// <summary>Alpha dithering strength in [0..100]</summary>
++        public int alpha_dithering_strength;
++        /// <summary>Padding for later use</summary>
++        private readonly UInt32 pad1;
++        /// <summary>Padding for later use</summary>
++        private readonly UInt32 pad2;
++        /// <summary>Padding for later use</summary>
++        private readonly UInt32 pad3;
++        /// <summary>Padding for later use</summary>
++        private readonly UInt32 pad4;
++        /// <summary>Padding for later use</summary>
++        private readonly UInt32 pad5;
++    };
++    #endregion
++}
+\ No newline at end of file
